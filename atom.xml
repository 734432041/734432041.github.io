<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code_dreamer</title>
  
  <subtitle>Magician</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://734432041.github.io/"/>
  <updated>2018-08-27T08:50:56.021Z</updated>
  <id>https://734432041.github.io/</id>
  
  <author>
    <name>LiLinfeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『小白日记』高阶函数学习笔记</title>
    <link href="https://734432041.github.io/2018/07/12/%E3%80%8E%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%E3%80%8F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://734432041.github.io/2018/07/12/『小白日记』高阶函数学习笔记/</id>
    <published>2018-07-12T14:13:04.000Z</published>
    <updated>2018-08-27T08:50:56.021Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高阶函数</strong>是指将<strong>函数作为参数</strong>传入的函数</p><h1 id="函数赋值给变量"><a href="#函数赋值给变量" class="headerlink" title="函数赋值给变量"></a>函数赋值给变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">sum(L)</span><br><span class="line">f = sum</span><br><span class="line">f(L)</span><br></pre></td></tr></table></figure><p>f指向了python的内置函数sum，我们可以通过f调用sum()函数</p><h1 id="函数名也是指向函数体的变量"><a href="#函数名也是指向函数体的变量" class="headerlink" title="函数名也是指向函数体的变量"></a>函数名也是指向函数体的变量</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">sum(L)</span><br><span class="line">//<span class="number">15</span></span><br><span class="line">sum = <span class="number">1</span></span><br><span class="line">sum(L)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#3&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sum(L)</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure><p>sum指向了计算列表和的函数，通过调用sum()函数，可以获得列表的和，在我们改变sum的值后，再调用sum()报错</p><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;是指将&lt;strong&gt;函数作为参数&lt;/strong&gt;传入的函数&lt;/p&gt;
&lt;h1 id=&quot;函数赋值给变量&quot;&gt;&lt;a href=&quot;#函数赋值给变量&quot; class=&quot;headerlink&quot; title=&quot;函数赋值给变量&quot;&gt;&lt;/a&gt;函数赋值给
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://734432041.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://734432041.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>『小白日记』Tkinter库学习笔记</title>
    <link href="https://734432041.github.io/2018/07/07/%E3%80%8E%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%E3%80%8FTkinter%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://734432041.github.io/2018/07/07/『小白日记』Tkinter库学习笔记/</id>
    <published>2018-07-07T06:59:30.000Z</published>
    <updated>2018-09-21T04:56:08.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tkinter库学习笔记"><a href="#Tkinter库学习笔记" class="headerlink" title="Tkinter库学习笔记"></a>Tkinter库学习笔记</h1><a id="more"></a><h2 id="Tkinter库简介"><a href="#Tkinter库简介" class="headerlink" title="Tkinter库简介"></a>Tkinter库简介</h2><blockquote><p>Tkinter库是python的标准Tk GUI工具包的接口。<br>Tkinter并不是唯一的python GUI工具包。然而，它是最常用的一种</p></blockquote><h2 id="导入Tkinter库"><a href="#导入Tkinter库" class="headerlink" title="导入Tkinter库"></a>导入Tkinter库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br></pre></td></tr></table></figure><h2 id="设置窗口信息"><a href="#设置窗口信息" class="headerlink" title="设置窗口信息"></a>设置窗口信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root = tkinter.Tk()                         <span class="comment">#创建一个窗口</span></span><br><span class="line">root.title(<span class="string">"Message Box!"</span>)                  <span class="comment">#设置窗口的标题</span></span><br><span class="line">root.geometry(<span class="string">'900x500+100+100'</span>)            <span class="comment">#设置窗口的大小和位置</span></span><br><span class="line">root.resizable(width = <span class="keyword">True</span>,height = <span class="keyword">True</span>)  <span class="comment">#设置窗口大小是否能够改变</span></span><br><span class="line"></span><br><span class="line">root.mainloop()                             <span class="comment">#设置窗口消息循环</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:  </p><ol><li>geometry的乘号用字母键x，而不是用*</li><li>geometry后面两个数字表示窗口的位置，以左上角为原点，第一个数表示向下的像素的数量，第二个数表示向右的像素的数量</li><li>geometry中间不能有多余空格</li></ol><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片1.png" alt=""></p><h2 id="设置控件信息"><a href="#设置控件信息" class="headerlink" title="设置控件信息"></a>设置控件信息</h2><h3 id="Lable控件"><a href="#Lable控件" class="headerlink" title="Lable控件"></a>Lable控件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lable = tkinter.Label(root,text = <span class="string">"Make a little progress every day!"</span>,bg=<span class="string">"black"</span>,fg=<span class="string">"white"</span>,font=(<span class="string">"黑体"</span>,<span class="number">20</span>),width = <span class="number">50</span>,height = <span class="number">4</span>) </span><br><span class="line"></span><br><span class="line">lable.pack(side = <span class="string">"left"</span>)</span><br></pre></td></tr></table></figure><p>属性：</p><ol><li>text: 要显示的文本信息</li><li>bg: Lable的背景颜色</li><li>fg: 字体的颜色</li><li>font: 字体的信息，大小</li><li>width: Lable的宽度</li><li>height: Lable的高度</li><li>justify: 文字的对齐方式(left,center,right)</li></ol><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片2.png" alt=""></p><h3 id="Button控件"><a href="#Button控件" class="headerlink" title="Button控件"></a>Button控件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> root</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        L = tkinter.Label(root, text=<span class="string">' '</span>.join(str(i) + <span class="string">'*'</span> + str(j) + <span class="string">'='</span> + str(i * j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>)))</span><br><span class="line">        L.pack()</span><br><span class="line"></span><br><span class="line"><span class="comment">#函数方式</span></span><br><span class="line">b1 = tkinter.Button(root,text = <span class="string">"函数方式"</span>,command = myfun)</span><br><span class="line">b1.pack()</span><br><span class="line"><span class="comment">#匿名方式</span></span><br><span class="line">b2 = tkinter.Button(root,text = <span class="string">"匿名函数方式"</span>,command = <span class="keyword">lambda</span>: print(<span class="string">"这是匿名函数的按钮"</span>) )</span><br><span class="line">b2.pack()</span><br><span class="line"><span class="comment">#退出窗口</span></span><br><span class="line">b3 = tkinter.Button(root,text = <span class="string">"退出窗口"</span>,command = root.quit)</span><br><span class="line">b3.pack()</span><br></pre></td></tr></table></figure><p>属性：  </p><ol><li>text: 按钮上要显示的文字信息</li><li>command：按了按扭要执行的代码段</li></ol><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片3.png" alt=""></p><h3 id="Entry控件"><a href="#Entry控件" class="headerlink" title="Entry控件"></a>Entry控件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showInfo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> root</span><br><span class="line"></span><br><span class="line">    L = tkinter.Label(root,text = entry.get())</span><br><span class="line">    L.pack()</span><br><span class="line"></span><br><span class="line">entry = tkinter.Entry(root,show = <span class="string">'*'</span>)</span><br><span class="line">entry.pack()</span><br><span class="line"></span><br><span class="line">Btn = tkinter.Button(root,text=<span class="string">"输出输入的内容"</span>,command = showInfo)</span><br><span class="line">Btn.pack()</span><br></pre></td></tr></table></figure><p>属性：</p><ol><li>show: 密文输入，不加show参数时明文输出</li></ol><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片4.png" alt=""></p><h3 id="Text控件（包括滚动条）"><a href="#Text控件（包括滚动条）" class="headerlink" title="Text控件（包括滚动条）"></a>Text控件（包括滚动条）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">t = tkinter.Text(root,width = <span class="number">900</span>,height = <span class="number">500</span>)   <span class="comment">#创建一个文本框</span></span><br><span class="line">sc = tkinter.Scrollbar()                        <span class="comment">#滚动条</span></span><br><span class="line"></span><br><span class="line">sc.pack(side = <span class="string">"right"</span>,fill = tkinter.Y)     <span class="comment">#side表示放在窗口的位置，fill表示填充方向</span></span><br><span class="line">t.pack(side = <span class="string">"right"</span>,fill = tkinter.Y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关联滚动条和文本框</span></span><br><span class="line">sc.config(command = t.yview)</span><br><span class="line">t.config(yscrollcommand = sc.set)</span><br><span class="line"></span><br><span class="line">s = <span class="string">'''</span></span><br><span class="line"><span class="string">这个冬季</span></span><br><span class="line"><span class="string">当熟悉的身影再次映入曼联球迷的眼帘</span></span><br><span class="line"><span class="string">当熟悉的身影向着本方腹地发起攻击</span></span><br><span class="line"><span class="string">爱恨交织的红魔也许很难理清这份复杂的心绪</span></span><br><span class="line"><span class="string">毕竟</span></span><br><span class="line"><span class="string">他曾是老特拉福德的天才七号</span></span><br><span class="line"><span class="string">是他们引以为傲的天之骄子</span></span><br><span class="line"><span class="string">他是天使，亦是魔鬼</span></span><br><span class="line"><span class="string">他是情人，也是敌人</span></span><br><span class="line"><span class="string">他年少成名，天赋过人</span></span><br><span class="line"><span class="string">他性格火爆，桀骜不驯</span></span><br><span class="line"><span class="string">他流着红色的血液，却拥有白色的灵魂</span></span><br><span class="line"><span class="string">他拥有王子的气质，却迷恋浪子的留情</span></span><br><span class="line"><span class="string">有多少人爱他就有多少人恨他</span></span><br><span class="line"><span class="string">在鲜明的爱恨情仇中，克里斯蒂亚诺 罗纳尔多依然华丽无比。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">每分每秒</span></span><br><span class="line"><span class="string">世界的每一个角落都有足球少年的诞生与成长</span></span><br><span class="line"><span class="string">克里斯蒂亚诺罗纳尔多出生自大西洋上的美丽海盗 马德拉岛</span></span><br><span class="line"><span class="string">他的父亲是美国前总统罗纳德里根的崇拜者</span></span><br><span class="line"><span class="string">因此把罗纳德的名字葡语话后就是罗纳尔多</span></span><br><span class="line"><span class="string">也就是今天这个响彻世界足坛的名字</span></span><br><span class="line"><span class="string">从里斯本的追风少年</span></span><br><span class="line"><span class="string">到梦剧场的王子</span></span><br><span class="line"><span class="string">如今他已是伯纳乌的国王</span></span><br><span class="line"><span class="string">炫目的球技和俊朗的外形</span></span><br><span class="line"><span class="string">让克里斯蒂亚诺罗纳尔多注定要成为一代天之骄子</span></span><br><span class="line"><span class="string">他的速度和爆发力</span></span><br><span class="line"><span class="string">他的冷静和从容</span></span><br><span class="line"><span class="string">他的过人和转身</span></span><br><span class="line"><span class="string">他的射门和盘带</span></span><br><span class="line"><span class="string">还有他的体力</span></span><br><span class="line"><span class="string">他的左右脚</span></span><br><span class="line"><span class="string">他的准确 精准</span></span><br><span class="line"><span class="string">他的效率</span></span><br><span class="line"><span class="string">种种特点 让他成为了这个无法复制的克里斯蒂亚诺罗纳尔多</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们常常怀念过去的故事 不是因为那些日子比现在美好</span></span><br><span class="line"><span class="string">而是它们是生命值得尊敬的一部分 且再也无法回去</span></span><br><span class="line"><span class="string">2003年8月8日</span></span><br><span class="line"><span class="string">c罗以1224万英镑空降曼彻斯特</span></span><br><span class="line"><span class="string">一个不经意的开始 却成为他巨星道路上重要的转折</span></span><br><span class="line"><span class="string">十八岁的c罗，带着满脸稚气初登梦剧场的舞台</span></span><br><span class="line"><span class="string">在签约仪式后主教练弗格森将七号战袍授予了他</span></span><br><span class="line"><span class="string">七，是多么传奇的数字</span></span><br><span class="line"><span class="string">在过去的半个世纪里，曼联最成功的球星几乎都身披七号</span></span><br><span class="line"><span class="string">乔治·贝斯特，罗布森 ，坎通纳，贝克汉姆</span></span><br><span class="line"><span class="string">一个个如雷贯耳的大名</span></span><br><span class="line"><span class="string">如今c罗成为了他新的主人</span></span><br><span class="line"><span class="string">七号的责任与荣耀在等待他去传承</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">t.insert(tkinter.INSERT, s)</span><br></pre></td></tr></table></figure><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片5.png" alt=""></p><h3 id="RadioButton"><a href="#RadioButton" class="headerlink" title="RadioButton"></a>RadioButton</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> v</span><br><span class="line"></span><br><span class="line">    message = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> v.get() == <span class="number">1</span>:</span><br><span class="line">        message += <span class="string">"I love apple!\n"</span></span><br><span class="line">    <span class="keyword">elif</span> v.get() == <span class="number">2</span>:</span><br><span class="line">        message += <span class="string">"I love orange!\n"</span></span><br><span class="line"></span><br><span class="line">    t.delete(<span class="number">0.0</span>,tkinter.END)</span><br><span class="line">    t.insert(tkinter.INSERT,message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v = tkinter.IntVar()                  <span class="comment">#设置一个变量表示选择的项目</span></span><br><span class="line"></span><br><span class="line">r1 = tkinter.Radiobutton(root,text = <span class="string">"apple"</span>,value = <span class="number">1</span>,variable = v,command = myfun2)</span><br><span class="line">r1.pack()</span><br><span class="line"></span><br><span class="line">r2 = tkinter.Radiobutton(root,text = <span class="string">"orange"</span>,value = <span class="number">2</span>,variable = v,command = myfun2)</span><br><span class="line">r2.pack()</span><br><span class="line"></span><br><span class="line">t = tkinter.Text(root,width = <span class="number">900</span>,height = <span class="number">100</span>)</span><br><span class="line">t.pack()</span><br></pre></td></tr></table></figure><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片6.png" alt=""></p><h3 id="Checkbutton"><a href="#Checkbutton" class="headerlink" title="Checkbutton"></a>Checkbutton</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> Var1,Var2,Var3,t</span><br><span class="line"></span><br><span class="line">    message = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> Var1.get() <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">        message += <span class="string">"first\n"</span></span><br><span class="line">    <span class="keyword">if</span> Var2.get() <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">        message += <span class="string">"second\n"</span></span><br><span class="line">    <span class="keyword">if</span> Var3.get() <span class="keyword">is</span> <span class="keyword">True</span>:</span><br><span class="line">        message += <span class="string">"third\n"</span></span><br><span class="line"></span><br><span class="line">    t.delete(<span class="number">0.0</span>, tkinter.END)          <span class="comment">#清除text中的内容</span></span><br><span class="line">    t.insert(tkinter.INSERT, message)   <span class="comment">#向text中添加模板</span></span><br><span class="line"></span><br><span class="line">Var1 = tkinter.BooleanVar()</span><br><span class="line">c1 = tkinter.Checkbutton(root,text = <span class="string">"1"</span>,variable = Var1,command = myfun1)</span><br><span class="line">c1.pack()</span><br><span class="line"></span><br><span class="line">Var2 = tkinter.BooleanVar()</span><br><span class="line">c2 = tkinter.Checkbutton(root,text = <span class="string">"2"</span>,variable = Var2,command = myfun1)</span><br><span class="line">c2.pack()</span><br><span class="line"></span><br><span class="line">Var3 = tkinter.BooleanVar()</span><br><span class="line">c3 = tkinter.Checkbutton(root,text = <span class="string">"3"</span>,variable = Var3,command = myfun1)</span><br><span class="line">c3.pack()</span><br><span class="line"></span><br><span class="line">t = tkinter.Text(root,width = <span class="number">900</span>,height = <span class="number">100</span>)</span><br><span class="line">t.pack()</span><br></pre></td></tr></table></figure><p><img src="/2018/07/07/『小白日记』Tkinter库学习笔记/图片7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tkinter库学习笔记&quot;&gt;&lt;a href=&quot;#Tkinter库学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Tkinter库学习笔记&quot;&gt;&lt;/a&gt;Tkinter库学习笔记&lt;/h1&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://734432041.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://734432041.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>操作系统复习</title>
    <link href="https://734432041.github.io/2018/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://734432041.github.io/2018/06/19/操作系统复习/</id>
    <published>2018-06-19T09:39:23.000Z</published>
    <updated>2018-07-02T10:30:30.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018年春季学期计算机操作系统原理复习提纲"><a href="#2018年春季学期计算机操作系统原理复习提纲" class="headerlink" title="2018年春季学期计算机操作系统原理复习提纲"></a>2018年春季学期计算机操作系统原理复习提纲</h1><p>（包括基本概念、管理原理、计算和综合应用）</p><a id="more"></a><h2 id="Part-I操作系统概述"><a href="#Part-I操作系统概述" class="headerlink" title="Part I操作系统概述"></a>Part I操作系统概述</h2><h3 id="操作系统的资源管理技术"><a href="#操作系统的资源管理技术" class="headerlink" title="操作系统的资源管理技术"></a>操作系统的资源管理技术</h3><h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><ol><li><p>空分复用共享  </p><blockquote><p>将资源的不同单位同时分配给不同的进程。  </p><ul><li>内存可以存分若干个进程</li><li>外存（磁盘）同时为多个进程保存信息</li></ul></blockquote></li><li><p>时分复用共享  </p><blockquote><p>轮流的使用资源，每个进程获得资源后使用一小会，多个进程分时地共享这类资源</p><ul><li>独占<br>进程获得资源后使用一个完整的周期后才会释放（磁带机）</li><li>时分共享<br>进程获得资源后可能随时被剥夺，被另一个进程抢占（处理器）</li></ul></blockquote><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><pre><code>&gt; 解决物理资源数量不足，提高服务的能力和水平      &gt;&gt; 一个物理资源虚拟成多个逻辑上的对应物      &gt;&gt; 多个物理资源虚拟成单个逻辑上的对应物 </code></pre><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><pre><code>&gt; 处理系统的复杂性，解决资源的易用性 </code></pre><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><blockquote><p>管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好运行环境的一种系统软件</p></blockquote></li></ol><ul><li>服务用户观点————操作系统作为用户接口和公共服务程序</li><li>进程交互观点————操作系统作为进程执行的控制者和协调者</li><li>系统实现观点————操作系统作为扩展机或虚拟机</li><li>资源管理观点————操作系统作为资源的管理者和控制者<h3 id="操作系统的主要特性"><a href="#操作系统的主要特性" class="headerlink" title="操作系统的主要特性"></a>操作系统的主要特性</h3></li><li>并发性<br>两个或两个以上的活动或事件在同一时间间隔内发生 </li><li>异步性(随机性)<br>多道程序中允许多个程序并发执行，并发活动会导致随机事件的发生，由于资源有限而程序众多，每个程序的执行并不是连贯的</li><li>共享性<br>计算机系统中的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3>（单道/多道批处理操作系统、分时操作系统、实时操作系统的基本特点）<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4>根据预先设定的调度策略选择若干作业并发的执行，系统资源利用率高，作业吞吐量大。</li><li>批量集中处理</li><li>多道程序运行</li><li>作业脱机工作<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4></li><li>同时性<br>若干终端用户联机使用计算机</li><li>独立性<br>终端用户彼此独立，互不干扰</li><li>即时性<br>请求在短时间内得到响应 </li><li>交互性<br>用户和机器交互，便于调试和排错 <h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><h3 id="操作系统提供给用户的几种接口"><a href="#操作系统提供给用户的几种接口" class="headerlink" title="操作系统提供给用户的几种接口"></a>操作系统提供给用户的几种接口</h3></li></ul><ol><li>程序接口<br>操作系统对外提供服务和功能的手段，由系统调用组成。 </li><li>操作接口<br>由一组控制命令或作业控制语言组成，是操作系统为用户提供的组织和控制其作业（应用程序）执行的手段 <h3 id="什么是系统调用-API、库函数和系统调用之间的区别和联系"><a href="#什么是系统调用-API、库函数和系统调用之间的区别和联系" class="headerlink" title="什么是系统调用? API、库函数和系统调用之间的区别和联系"></a>什么是系统调用? API、库函数和系统调用之间的区别和联系</h3></li></ol><ul><li>系统调用<blockquote><p>系统调用，指运行在用户空间的应用程序向操作系统内核请求某些服务的调用过程。<br>是<code>应用程序</code>同<code>系统</code>之间的接口。</p></blockquote></li><li>库函数<blockquote><p>库函数，是由用户或组织自己开发的，具有一定功能的函数集合。 </p></blockquote></li><li>API<blockquote><p>API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。  </p></blockquote><h4 id="系统调用与函数调用之间的区别"><a href="#系统调用与函数调用之间的区别" class="headerlink" title="系统调用与函数调用之间的区别"></a>系统调用与函数调用之间的区别</h4></li></ul><ol><li>调用的形式和实现方式不同</li><li>被调用代码的位置不同</li><li>提供方式不同<h3 id="什么是原语？用户应用程序如何调用原语功能？举例Linux原语"><a href="#什么是原语？用户应用程序如何调用原语功能？举例Linux原语" class="headerlink" title="什么是原语？用户应用程序如何调用原语功能？举例Linux原语"></a>什么是原语？用户应用程序如何调用原语功能？举例Linux原语</h3><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4>原语是由若干机器指令构成，用于完成某种特定的系统功能的一段程序，具有<code>不可分割性</code>，即原语的执行必须是连续的，不可被打断的。<h4 id="举例Linux原语"><a href="#举例Linux原语" class="headerlink" title="举例Linux原语"></a>举例Linux原语</h4></li><li>进程控制原语：fork()</li><li>系统调用：exec函数族</li><li>系统调用终止进程：exit()</li><li>系统调用等待子程序暂停或中止：wait()</li></ol><h3 id="第一章课后计算题"><a href="#第一章课后计算题" class="headerlink" title="第一章课后计算题"></a>第一章课后计算题</h3><h2 id="Part-II处理器管理"><a href="#Part-II处理器管理" class="headerlink" title="Part II处理器管理"></a>Part II处理器管理</h2><h3 id="CPU的两种工作状态"><a href="#CPU的两种工作状态" class="headerlink" title="CPU的两种工作状态"></a>CPU的两种工作状态</h3><h4 id="内核态（系统态、管理态、管态）"><a href="#内核态（系统态、管理态、管态）" class="headerlink" title="内核态（系统态、管理态、管态）"></a>内核态（系统态、管理态、管态）</h4><pre><code>操作系统管理管理程序运行时所处的状态，处理器正在运行可信系统软件，此时全部机器指令都被允许在处理机上执行，程序可访问所有内存单元和系统资源，且具有改变处理器状态的能力</code></pre><h4 id="用户态（目态）"><a href="#用户态（目态）" class="headerlink" title="用户态（目态）"></a>用户态（目态）</h4><pre><code>正在运行非可信应用程序，此时无法执行特权指令，且访问仅限于当前处理器上执行程序所在的地址空间，防止操作系统受到应用程序的侵害</code></pre><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断    不被阻塞<br>异常    可以阻塞</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是指程序执行过程中遇到急需处理的事件时，中止现行程序在CPU上的运行，转而处理相应的事件处理程序，待事件处理完成后再返回断点继续执行的过程。</p><h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可将中断划分为<code>外中断</code>和<code>内中段</code></p><h6 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h6><p>外中断又称中断或异步中断，是指来自处理器之外的中断信号（时钟中断、键盘中断、外部设备中断）。外中断又分为<code>可屏蔽中断</code>和<code>不可屏蔽中断</code>。在处理级别较高的中断时，往往会部分或全部屏蔽低级中断。</p><h6 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h6><p>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。内中断可细分为：  </p><ol><li>访管中断，由执行系统调用引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性中断，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等<h4 id="中断响应需要执行的四件事"><a href="#中断响应需要执行的四件事" class="headerlink" title="中断响应需要执行的四件事"></a>中断响应需要执行的四件事</h4></li><li>发现中断源</li><li>保护现场</li><li>执行中断\异常处理程序</li><li>恢复现场<h3 id="进程与程序、进程与线程之间的区别联系"><a href="#进程与程序、进程与线程之间的区别联系" class="headerlink" title="进程与程序、进程与线程之间的区别联系"></a>进程与程序、进程与线程之间的区别联系</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><code>进程</code>是操作系统中最<code>最基本</code>、<code>最重要</code>的概念，指一个程序的一次执行过程。<h5 id="进程的目的"><a href="#进程的目的" class="headerlink" title="进程的目的"></a>进程的目的</h5></li><li>刻画进程的并发性</li><li>解决资源的共享性<h5 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h5></li><li>动态性，是程序的一次执行过程，有生命周期，是动态的概念</li><li>共享性，多个不同的进程可执行相同的程序</li><li>独立性，每个进程都是一个独立的实体，有自己的虚存空间、程序计数器、内部状态</li><li>制约性，多个进程因为共享资源或协同工作产生相互的制约关系</li><li>并发性，多个进程在时间上可以重叠，可以并发。</li></ol><h5 id="进程和程序的区别和联系"><a href="#进程和程序的区别和联系" class="headerlink" title="进程和程序的区别和联系"></a>进程和程序的区别和联系</h5><ol><li>区别<ul><li>进程是动态的，程序是静态的</li><li>进程有一定的生命周期，而程序是一组指令的集合</li><li>一个程序可以对应多个进程，一个进程只能对应一个程序</li></ul></li><li>联系<ul><li>程序不能单独执行，只能加载到内存中，系统分配资源后执行，这种执行的程序就叫做进程<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5>线程是进程的一个实体,也是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程<br>线程自己基本上不拥有系统资源，也没有自己的地址空间，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化</li></ul></li></ol><h5 id="进程和线程的区别和联系"><a href="#进程和线程的区别和联系" class="headerlink" title="进程和线程的区别和联系"></a>进程和线程的区别和联系</h5><ol><li>区别  </li></ol><ul><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</li><li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li><li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li><li>系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。</li></ul><ol start="2"><li>联系</li></ol><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li><li>处理机分给线程，即真正在处理机上运行的是线程。</li><li>线程是指进程内的一个执行单元，也是进程内的可调度实体。</li></ul><h3 id="父进程与子进程之间的关系"><a href="#父进程与子进程之间的关系" class="headerlink" title="父进程与子进程之间的关系"></a>父进程与子进程之间的关系</h3><p>子进程的代码段和父进程共享，子进程的其他资源是父进程的一个副本，也就是说，在创建子进程后，子进程和父进程就是两个独立的进程。</p><h3 id="进程的3态模型、进程的5态模型、引发各种状态转换的原因"><a href="#进程的3态模型、进程的5态模型、引发各种状态转换的原因" class="headerlink" title="进程的3态模型、进程的5态模型、引发各种状态转换的原因"></a>进程的3态模型、进程的5态模型、引发各种状态转换的原因</h3><p><a href="https://blog.csdn.net/qwe6112071/article/details/70473905" target="_blank" rel="noopener">https://blog.csdn.net/qwe6112071/article/details/70473905</a></p><h3 id="操作系统的三级调度"><a href="#操作系统的三级调度" class="headerlink" title="操作系统的三级调度"></a>操作系统的三级调度</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p>又称作业调度，长程调度，主要功能是按照作业调度策略，从后备作业调度队列挑选若干作业进入内存，分配资源并创建进程</p><h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p>又称平衡调度，中程调度，主要功能是根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中进程的对换工作。从等待队列中挑选作业到挂起等待队列，从挂起等待队列挑选作业到挂起就绪队列</p><h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p>又称进程调度/线程调度，短程调度。功能是根据某种原则，决定就绪队列中的哪个进程获得CPU，并将CPU给它用</p><p><img src="/2018/06/19/操作系统复习/20170220154733687.jpg" alt="处理器三级调度模型"></p><h3 id="常用的作业调度算法、进程调度算法"><a href="#常用的作业调度算法、进程调度算法" class="headerlink" title="常用的作业调度算法、进程调度算法"></a>常用的作业调度算法、进程调度算法</h3><ol><li>先来先服务算法(FCFS),按照作业进入系统后备队列的先后次序来挑选作业。（同样适用于进程/线程调度算法，每次从就绪队列中选择最先进入的进程/队列，它会一直运行到完成或者被阻塞让出处理器为止）(非剥夺算法)</li><li>最短作业优先算法(SJF),以进入系统作业所要求的CPU运行时间长短为标准，选取预计计算事件最短的作业。(非剥夺算法)</li><li>最短剩余时间优先算法(SRTF),当某进程/某线程进入就绪队列，若它所需要的CPU运行时间比当前运行进程/线程时间短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行(剥夺算法)</li><li>最高响应比优先算法(HRRF)<blockquote><p>响应比 = 作业周转时间/作业处理时间</p><pre><code>=(作业等待时间+作业处理时间)/作业处理时间=1+作业等待时间/作业处理时间</code></pre><p> 按响应比从大到小顺序执行<br> 当响应比算法用于进程调度时<br>响应比 = 1+进程等待时间/进程估计计算时间<br> (非剥夺算法)</p></blockquote></li><li>优先级算法，根据确定的优先级选取进程/线程，总是选择就绪队列中优先级最高者投入运行。</li><li>轮转调度算法(时间片调度算法)，调度程序每次把CPU分配给就绪队列首进程/线程使用规定的时间间隔，成为时间片(10-200ms)，就绪队列中的每个进程/线程轮流的运行一个时间片，一个时间片耗尽时，强制让出CPU<h3 id="第二章课后作业调度、进程调度有关的计算题"><a href="#第二章课后作业调度、进程调度有关的计算题" class="headerlink" title="第二章课后作业调度、进程调度有关的计算题"></a>第二章课后作业调度、进程调度有关的计算题</h3></li></ol><h2 id="PartIII同步、通信与死锁"><a href="#PartIII同步、通信与死锁" class="headerlink" title="PartIII同步、通信与死锁"></a>PartIII同步、通信与死锁</h2><h3 id="进程并发的概念；互斥、同步的概念"><a href="#进程并发的概念；互斥、同步的概念" class="headerlink" title="进程并发的概念；互斥、同步的概念"></a>进程并发的概念；互斥、同步的概念</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>一组进程的执行在时间上是重叠的，就称他们是并发执行的<br>并发的实质是一个处理器在几个进程之间的<code>多路复用</code>，并发是对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</p><h4 id="并发执行进程的目的"><a href="#并发执行进程的目的" class="headerlink" title="并发执行进程的目的"></a>并发执行进程的目的</h4><ul><li>充分发挥硬件的并行性，提高系统效率</li><li>并发程序设计是多道程序设计的基础<h4 id="进程互斥的概念"><a href="#进程互斥的概念" class="headerlink" title="进程互斥的概念"></a>进程互斥的概念</h4><code>进程互斥</code>是指若干个进程因相互争夺独占型资源时所产生的<code>竞争制约</code>关系<h4 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h4><code>进程同步</code>指为完成共同任务的并发进程基于某个条件来<code>协调</code>它们的活动，因为需要在某些位置上排定<strong>执行的先后次序而等待</strong>、<strong>传递信号或消息</strong>所产生的<code>协作制约</code>关系  <h4 id="同步和互斥的关系"><a href="#同步和互斥的关系" class="headerlink" title="同步和互斥的关系"></a>同步和互斥的关系</h4></li></ul><ol><li><code>互斥</code>是不能同时使用</li><li><code>同步</code>是不但不能同时使用，而且由使用的先后顺序</li><li>互斥关系是一种<strong>特殊</strong>的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</li></ol><p><code>并发进程共享临界资源，分析如果不加控制，可能会出现的不确定的结果</code></p><h4 id="互斥管理准则"><a href="#互斥管理准则" class="headerlink" title="互斥管理准则"></a>互斥管理准则</h4><ul><li><code>空闲让进</code>：当没有进程在临界区时，任何需要进入临界区的进程都允许立即进入。 </li><li><code>忙则等待</code>：在共享同一对象的所有进程中，一次只能有一个进程进入临界区。其它要求进入临界区的进程只能等待。 </li><li><code>有限等待</code>：任何一个进程经有限时间等待后都能进入临界区，不允许出现进程死锁或饥饿的情况发生。 </li><li><code>让权等待</code>：当一个进程不能进入临界区时要立即阻塞自己，释放处理机让其它进程使用，避免“忙等”。 </li></ul><h3 id="分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）"><a href="#分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）" class="headerlink" title="分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）"></a>分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）</h3><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>             </span></span><br><span class="line"><span class="function">Begin                     </span></span><br><span class="line">……                     </span><br><span class="line"> While (turn≠<span class="number">1</span>) <span class="keyword">do</span> skip;        </span><br><span class="line">  Critical section;          </span><br><span class="line">    turn = <span class="number">2</span>;                </span><br><span class="line">……                         </span><br><span class="line">end.                     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">While (turn≠<span class="number">2</span>) <span class="keyword">do</span> skip;</span><br><span class="line"> Critical section;</span><br><span class="line">  turn = <span class="number">1</span>;</span><br><span class="line">……</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><p>分析：主要出现了两个问题。  </p><ol><li>用0和1代表两个进程，它们只能按照01010101的顺序访问临界区，大大降低了操作系统的效率</li><li>如果出现一个进程因为错误而退出，没有修改turn值，那么另一个进程就用于不能得到进入临界区的机会<br>主要违反了<code>空闲让进</code>，<code>有限等待</code>原则。 <h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>            </span></span><br><span class="line"><span class="function">Begin                                </span></span><br><span class="line">……                         </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> skip;  </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;      </span><br><span class="line">Critical section;               </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;       </span><br><span class="line">……                             </span><br><span class="line">end.                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> skip;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li></ol><p>分析：主要问题是，当一个进程通过了<code>while</code>循环，而还没有修改Flag变量，此时系统切换到另一个进程执行时，也能够通过<code>while</code>循环，照成了两个进程同时进入临界区<br>主要违反了<code>忙则等待</code>原则</p><h4 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>            </span></span><br><span class="line"><span class="function">Begin                      </span></span><br><span class="line">……                        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;      </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> skip;    </span><br><span class="line">Critical section;        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;      </span><br><span class="line">……                 </span><br><span class="line">end.                        </span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> skip;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>分析：主要问题是，当第一个进程修改了Flag值，还没由通过<code>while</code>循环，此时系统切换到另一个进程执行时，也修改了了Flag值，那么两个进程都无法通过<code>while</code>循环。照成了死锁。<br>主要违反了<code>空闲让进</code>原则</p><h4 id="第四次尝试"><a href="#第四次尝试" class="headerlink" title="第四次尝试"></a>第四次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>                            </span></span><br><span class="line"><span class="function">Begin                                        </span></span><br><span class="line">……                               </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;                  </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span>       </span><br><span class="line">&#123;flag[<span class="number">1</span>]=<span class="literal">false</span>;                    </span><br><span class="line">  flag[<span class="number">1</span>]=<span class="literal">true</span>&#125;;                   </span><br><span class="line">Critical section;       </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;       </span><br><span class="line">……                                     </span><br><span class="line">end.                                           </span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> </span><br><span class="line">&#123;flag[<span class="number">2</span>]=<span class="literal">false</span>;</span><br><span class="line">    flag[<span class="number">2</span>]=<span class="literal">true</span>&#125;;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>分析：主要的问题是，可能出现两个进程并发度极高，同时修改Flag值，又同时进入<code>while</code>循环，同时释放Flag值，导致了两个进程都不能时用共享区<br>违反了<code>空闲让进</code>原则</p><h4 id="“正确”的算法"><a href="#“正确”的算法" class="headerlink" title="“正确”的算法"></a>“正确”的算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>                  </span></span><br><span class="line"><span class="function">Begin                  </span></span><br><span class="line">……        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;     </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span>       </span><br><span class="line"><span class="keyword">if</span> (turn=<span class="number">2</span>)      </span><br><span class="line">&#123;flag[<span class="number">1</span>]=<span class="literal">false</span>; </span><br><span class="line"> <span class="keyword">while</span> (turn=<span class="number">2</span>) <span class="keyword">do</span> skip; </span><br><span class="line"> flag[<span class="number">1</span>]=<span class="literal">true</span>&#125;; </span><br><span class="line">Critical section;                   </span><br><span class="line">turn=<span class="number">2</span>;      turn=<span class="number">1</span>;</span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;      </span><br><span class="line">……         ……</span><br><span class="line">end.                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">Flag[2] = true;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> (turn=<span class="number">1</span>)</span><br><span class="line">&#123;flag[<span class="number">2</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (turn=<span class="number">1</span>) <span class="keyword">do</span> skip;</span><br><span class="line">    flag[<span class="number">2</span>]=<span class="literal">true</span>&#125;;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>分析：基本解决了用软件方式实现互斥算法，但是，在<code>while</code>里执行的时无用的代码段，还是降低了系统的效率。<br>此外，使用Dekker算法只能解决两个进程的互斥问题，在面对多进程互斥时算法的编写时非常复杂的</p><h3 id="应用信号量机制（PV操作）解决进程同步互斥问题"><a href="#应用信号量机制（PV操作）解决进程同步互斥问题" class="headerlink" title="应用信号量机制（PV操作）解决进程同步互斥问题"></a>应用信号量机制（PV操作）解决进程同步互斥问题</h3><h4 id="信号量机制原理"><a href="#信号量机制原理" class="headerlink" title="信号量机制原理"></a>信号量机制原理</h4><p>为每个临界资源设置一个信号量，负责在多个进程之间转发互斥信息。当一个进程需要互斥使用某个临界资源时，可通过对信号量的P操作，了解该资源的空闲情况。当它使用完该临界资源后，又可通过对相关信号量的V操作，让其它需要该资源的进程感知到它的离去。</p><h4 id="p原语的功能"><a href="#p原语的功能" class="headerlink" title="p原语的功能"></a>p原语的功能</h4><pre><code>P原语具有“阻塞”功能，当某个临界资源被其他进程占用时，就将自己阻塞；</code></pre><h4 id="V原语的功能"><a href="#V原语的功能" class="headerlink" title="V原语的功能"></a>V原语的功能</h4><pre><code>V原语具有“唤醒”功能，它能将等待该资源的进程唤醒。</code></pre><p>（课件例题、练习题、作业题）<br>   生产者-消费者类型、读者-写者类型、理发师类型、<br>   哲学家就餐类型、进程DAG图类型</p><h3 id="父子进程之间进行通信的几种方式（结合实验课程）"><a href="#父子进程之间进行通信的几种方式（结合实验课程）" class="headerlink" title="父子进程之间进行通信的几种方式（结合实验课程）"></a>父子进程之间进行通信的几种方式（结合实验课程）</h3><h4 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h4><h5 id="软中断的概念"><a href="#软中断的概念" class="headerlink" title="软中断的概念"></a>软中断的概念</h5><p>不必由硬件产生中断源而引起的中断称为软中断，软中断是利用硬中断的概念，采用软件方法对中断机制进行模拟，实现宏观上的异步执行。<br>信号是一种软中断机制，信号的发送者相当于中断源（或是内核，或是进程），而信号的接收者必然是一个进程（相当于CPU）</p><h5 id="软中断的用法"><a href="#软中断的用法" class="headerlink" title="软中断的用法"></a>软中断的用法</h5><p>用于内核或进程对某个进程发出中断，向进程通知某个特定事件发生或迫使进程执行信号处理程序</p><h5 id="中断机制和信号机制的比较"><a href="#中断机制和信号机制的比较" class="headerlink" title="中断机制和信号机制的比较"></a>中断机制和信号机制的比较</h5><p>相同点：</p><ol><li>两者在概念上是一致的，进程接收到信号和CPU接收中断是相似的。</li><li>两者都是异步的，CPU和进程在工作过程中都不知道中断和信号何时产生，不需要停下来等到信号的发生。</li><li>两者在在实现上都采用向量表，中断机制设置中断向量表，信号机制设置信号向量表。</li><li>两者均有屏蔽设施，中断机制可以对中断源屏蔽，信号机制可以设置信号屏蔽位，对发来的信号不予理睬。<br>区别:</li><li>中断机制由软件加硬件实现，信号机制完全由软件实现</li><li>中断向量表和中断处理程序位于系统空间，信号向量表位于系统空间，而信号处理程序由程序提供。<h4 id="管道通讯"><a href="#管道通讯" class="headerlink" title="管道通讯"></a>管道通讯</h4>管道是连接读写程序的一个特殊文件，允许按照FIFO方式传送数据，使进程同步执行。<br>管道是单向的<br>发送进程视管道为输出文件，以字符流的形式把数据送入管道。<br>接收进程视管道为输入文件，从管道中接收文件。</li></ol><h4 id="共享内存通讯"><a href="#共享内存通讯" class="headerlink" title="共享内存通讯"></a>共享内存通讯</h4><p>共享内存是指两个或多个进程共同拥有一块内存区，该区中的进程可被进程访问。</p><h4 id="消息队列通讯"><a href="#消息队列通讯" class="headerlink" title="消息队列通讯"></a>消息队列通讯</h4><h3 id="死锁的基本概念、死锁产生的原因、4个必要条件"><a href="#死锁的基本概念、死锁产生的原因、4个必要条件" class="headerlink" title="死锁的基本概念、死锁产生的原因、4个必要条件"></a>死锁的基本概念、死锁产生的原因、4个必要条件</h3><h4 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h4><p>如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁</p><h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ol><li>资源的可用量小于需求量</li><li>动态资源分配策略</li><li>偶然性</li></ol><h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ol><li>互斥条件：临界资源是独占资源，进程应该互斥且排他的使用这些资源</li><li>占有和等待条件：进程在请求资源得不到满足而等待时，不释放已拥有的资源</li><li>不剥夺条件：进程获得的资源只能由进程自愿释放，不允许被其他进程剥夺</li><li>循环等待条件（环路条件）：循环等待链，每个进程都在等待链中等待下一个进程所持有的资源，造成永久等待状态</li></ol><h3 id="死锁预防、死锁避免、死锁检测的概念"><a href="#死锁预防、死锁避免、死锁检测的概念" class="headerlink" title="死锁预防、死锁避免、死锁检测的概念"></a>死锁预防、死锁避免、死锁检测的概念</h3><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁的预防主要是破坏死锁产生的四个必要条件。</p><ul><li>破坏条件一：进程可以同时使用资源，但是有很多资源（如可写文件、键盘、磁带机等）是不能够被同时使用的</li><li>破坏条件二：主要采用静态分配策略，即在进程执行前就分配给它所需要的资源，主要问题是，资源利用率和进程并发度降低。</li><li>破坏条件三：剥夺调度能够有效的预防死锁，但是只适用于内存和处理器资源。</li><li>破坏条件四：采用按层次分配策略，将系统的所有资源排列到不同的层次中，一个进程得到某层次的资源后，才能申请更高一层的资源，同样，一个进程在释放某一层次资源前，要释放所有更高层次的资源。</li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>采用银行家算法（动态资源分配策略），允许操作系统中同时存在前三个必要条件，通过合适的资源分配算法，确保不会出现进程循环等待链。</p><h5 id="银行家算法的数据结构"><a href="#银行家算法的数据结构" class="headerlink" title="银行家算法的数据结构"></a>银行家算法的数据结构</h5><ol><li>每类资源总数向量<code>Resource = [R1,R2,R3,...,Rm]</code></li><li>每类资源当前可用量<code>Available = [V1,V2,V3,...,Vm]</code></li><li>每个进程对各类资源的最大需求矩阵<code>Claim[i,j] = k</code>,表示<code>进程pi</code>对<code>资源Rj</code>的最大需求量为<code>k</code>个</li><li>每个进程已经拥有的各类资源矩阵<code>Allocation[i,j] = k</code>，表示<code>进程pi</code>已经拥有<code>资源Rj</code>的数量为<code>k</code>个</li><li>每个进程对各类资源的尚需矩阵<code>Need[i,j] = k</code>,表示<code>进程Pi</code>对<code>资源Rj</code>还需要<code>k</code>个，<code>Need[i,j] = Claim[i,j] - Allocation[i,j]</code></li><li>每个进程当前申请各类资源的数量矩阵<code>Request[i,j] = k</code>,表示<code>进程Pi</code>当前申请<code>资源Rj</code>的数目为<code>k</code>个<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><h5 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h5>死锁检测程序  </li><li>如果进程 - 资源分配图中<strong>无环路</strong>，此时系统没有发生死锁</li><li>如果进程 - 资源分配图中<strong>有环路</strong>，且每个资源类中<strong>仅有一个资源</strong>，则系统中发生死锁。此时，环路是系统发生死锁的<strong>充分必要条件</strong>，环路中的进程就是死锁进程。</li><li>如果进程 - 资源分配图中<strong>有环路</strong>，且所涉及的资源类中有<strong>多个资源</strong>，则环路的产生只是死锁产生的<strong>必要条件而不是充分条件</strong>,系统未必会发生死锁</li></ol><h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><p>系统处于死锁状态的充分必要条件是：当且仅当此状态的进程 - 资源分配图是不可完全简化的，这一充分条件称为死锁定理。</p><h3 id="第三章课后应用题和计算题"><a href="#第三章课后应用题和计算题" class="headerlink" title="第三章课后应用题和计算题"></a>第三章课后应用题和计算题</h3><h2 id="PartIV存储管理"><a href="#PartIV存储管理" class="headerlink" title="PartIV存储管理"></a>PartIV存储管理</h2><h3 id="静态地址重定位和动态地址重定位"><a href="#静态地址重定位和动态地址重定位" class="headerlink" title="静态地址重定位和动态地址重定位"></a>静态地址重定位和动态地址重定位</h3><ul><li>物理地址：绝对地址</li><li>逻辑地址：相对地址</li><li>重定位：逻辑地址 –&gt; 物理地址<h4 id="静态地址重定位"><a href="#静态地址重定位" class="headerlink" title="静态地址重定位"></a>静态地址重定位</h4></li><li>地址转换工作在进程执行前一次完成；</li><li>无须硬件支持，易于实现，但不允许程序在执行过程中移动位置。</li></ul><h4 id="动态地址重定位"><a href="#动态地址重定位" class="headerlink" title="动态地址重定位"></a>动态地址重定位</h4><ul><li>地址转换推迟到最后的可能时刻，即进程执行时才完成；</li><li>允许程序在主存中移动、便于主存共享、主存利用率高。</li></ul><h3 id="动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）"><a href="#动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）" class="headerlink" title="动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）"></a>动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）</h3><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>又称为<strong>静态分区模式</strong>，内存空间被划分为数目固定的分区，各分区的大小不等，每个分区至装入一个作业，若多个分区都装有作业，它们可以并发执行。</p><h4 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h4><p>又称为<strong>动态分区模式</strong>，按照作业大小划分分区，但是划分的时间，大小，位置都是动态的。</p><h5 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h5><p>指的是作业获得的空间大于需求的空间时多出来的一小部分用户根本不需要的空闲区。</p><h5 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h5><p>指的是在使用可变分区管理方法时，进程之间形成的一些零零星星的小空闲区。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据结构由两张表组成，<code>已分配分区表</code>，<code>未分配分区表</code>，当装入新作业时，从未分配分区表中找出一个足够容纳它的空闲区，将此区分为两部分，一部分用来装入新作业，成为已分配区，另一部分仍是空闲区，将非空闲区的部分登记在已分配分区表（起始地址，占用长度），修改未分配分区该空闲区的起始地址和占用长度。由于分区的数目不定，两个表都可以使用链表实现。</p><ol><li>内存分配表（MAT表）</li></ol><ul><li>分区号：每个分区都有一个编号，用以区别不同分区。</li><li>起始地址：分区的起始地址，即首地址。</li><li>长度：分区的总长，一般以KB为单位。</li><li>占用标志：记录分区的使用状态。若占用标志为0，表明该分区为空闲，可以进行分配。若为非0（比如，填的是一个进程名称），意味着该分区已分配给进程使用。</li></ul><ol start="2"><li><p>空闲区表/链<br>空闲区表是记录内存空闲区状况的数据结构。将当前空闲区单独组成一个链表是一种好方法。空闲区链中每一个结点代表一个空闲区。其中包括：分区号、起始地址、长度、链接指针等。</p></li><li><p>位示图<br>位示图是存储器的一种存储空间映像，系统可以根据位图来进行存储空间的管理。对每个位用0或1表示是否分配</p></li></ol><h4 id="主存分配算法"><a href="#主存分配算法" class="headerlink" title="主存分配算法"></a>主存分配算法</h4><ol><li>最先适应（first fit）：在未分配区找到的第一个长度满足要求的空闲区就分配。有利于高地址保持一个较大的空闲区用于大作业的装入，但是内存高低地址使用不平均，对回收算法也带来麻烦。</li><li>下次适应（next fit）（循环最先适应(Circlu first fit)）：从未分配区上次扫描结束处顺序查找未分配区，找到第一个长度满足要求的空闲区就分配。是first fit的变化，能够缩短查找时间，使内存的利用率更加均衡。</li><li>最优适应（best fit）：扫描整个未分配表，从空闲区中挑选一个能够满足用户进程要求的最小空闲区。保证不会分割大的空闲区，内存利用率高，缺点是，如果空闲区比所需要的长度略长，分割后会使得剩下的空闲区很小，形成了很多外碎片，不能利用，此外，每次都要对内存的每个未分配区查找一次，时间开销很大。</li><li>最坏适应（worst fit）：扫描整个未分配表，找出满足要求的最长的空闲区分配。这样，每次剩下的空闲区不会太小，减少了外碎片的产生。但是没有解决时间开销的问题。而且，每次将大的空闲区分成小块，对中小作业比较友好，不利于大作业的分配。</li></ol><h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p>当操作系统要回收一个已经分配的空闲块时</p><ol><li>在未分配表中按照<code>空闲块的大小</code>或<code>地址</code>找到一个合适的位置</li><li>插入一个结点，包括空闲块的起始地址，长度，占用标识，下个块的地址</li><li>如果该空闲块的前后有空闲块，可以合并</li></ol><h4 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h4><p> 固定分区存储管理<br><img src="/2018/06/19/操作系统复习/图片1.jpg" alt="固定分区存储管理地址转换和存储保护"></p><p> 动态分区存储管理<br><img src="/2018/06/19/操作系统复习/图片2.jpg" alt="可变分区地址转换与存储保护"></p><h3 id="内存不足的存储管理技术"><a href="#内存不足的存储管理技术" class="headerlink" title="内存不足的存储管理技术"></a>内存不足的存储管理技术</h3><h4 id="移动技术-程序浮动"><a href="#移动技术-程序浮动" class="headerlink" title="移动技术(程序浮动)"></a>移动技术(程序浮动)</h4><p><img src="/2018/06/19/操作系统复习/图片3.jpg" alt="移动技术"></p><h5 id="程序浮动的要求"><a href="#程序浮动的要求" class="headerlink" title="程序浮动的要求"></a>程序浮动的要求</h5><ol><li>程序不能正在运行</li><li>采用动态内存分配</li><li>不能为堵塞等待IO的进程</li></ol><h4 id="对换技术（主存扩充）"><a href="#对换技术（主存扩充）" class="headerlink" title="对换技术（主存扩充）"></a>对换技术（主存扩充）</h4><ul><li>实存储器（实存）：内存</li><li>虚存储器（虚存）：磁盘SWAP区（虚拟成内存使用）</li></ul><h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p>当一个或多个驻留进程处于堵塞态时，选择其中一个进程，暂时移出内存，让其他进程使用内存，把磁盘中的某个进程换入内存。</p><ul><li>交换整个作业————用于单道系统</li><li>交换整个进程————连续存储管理</li><li>交换页面/段面————虚拟存储管理</li></ul><h5 id="磁盘文件区和交换区的不同"><a href="#磁盘文件区和交换区的不同" class="headerlink" title="磁盘文件区和交换区的不同"></a>磁盘文件区和交换区的不同</h5><ul><li><p>存储方式的不同<br>文件区中的信息是以文件形式存放的，为了提高空间利用率，一般采取<code>离散存储</code>方式<br>交换区中的信息是按字符流方式存放，多采用<code>连续存储</code>形式。</p></li><li><p>访问速度的不同<br>文件区的存储空间特别大，为了提高检索效率一般通过建立目录对文件实现访问，也就是<code>间接地址访问</code><br>交换区空间较小，可按外存地址<code>直接访问</code>，因此速度快</p></li><li><p>存取时间的不同<br>文件区的存储适合于<code>较长久</code>的数据存储<br>交换区作为临时数据的存放处，只存放<code>短期</code>的数据。 </p></li></ul><h4 id="覆盖技术（主存扩充）"><a href="#覆盖技术（主存扩充）" class="headerlink" title="覆盖技术（主存扩充）"></a>覆盖技术（主存扩充）</h4><p>覆盖技术，是程序运行过程中，在不同时刻把同一存储区分配给不同程序段或数据段，<code>实现存储区共享</code>的一种内存分配技术。<br>覆盖技术通常与<code>单一连续区分配</code>、<code>固定分区分配</code>和<code>动态分区分配</code>等存储管理技术配合使用。<br>每一个用户程序都被分为若干程序段，一部分是经常要用的基本部分，作为常驻程序（<code>非覆盖段</code>）；另一部分不经常使用，可以让它们在需要时临时装入（<code>可覆盖段</code>）。当一段在内存中的程序运行完毕（或者暂时不运行）时，可以令它们放弃驻留权，让另一段程序占用它在内存中的位置。</p><h3 id="分页式存储管理的管理机制（基本分页、请求分页）"><a href="#分页式存储管理的管理机制（基本分页、请求分页）" class="headerlink" title="分页式存储管理的管理机制（基本分页、请求分页）"></a>分页式存储管理的管理机制（基本分页、请求分页）</h3><h4 id="分页存储管理的基本原理"><a href="#分页存储管理的基本原理" class="headerlink" title="分页存储管理的基本原理"></a>分页存储管理的基本原理</h4><p>将内存空间划分为大小固定相等的块（Frame帧、页框、主存块），且每一块空间较小<br>将每个进程划分为同样大小的块(page页)<br>进程中称为页的块指定到内存中称为帧的块(一页对应一帧)</p><h5 id="分页存储管理和固定分区的区别"><a href="#分页存储管理和固定分区的区别" class="headerlink" title="分页存储管理和固定分区的区别"></a>分页存储管理和固定分区的区别</h5><ol><li>每个帧非常小</li><li>一个进程可以占用多个帧</li><li>每个程序所占用的多个帧不必是连续的</li></ol><h4 id="分页存储管理的数据结构"><a href="#分页存储管理的数据结构" class="headerlink" title="分页存储管理的数据结构"></a>分页存储管理的数据结构</h4><ol><li>位示图（与动态分区管理相同）</li><li>页表(Page Table, PT):每个进程一张，记录了本进程的分页和占用帧的情况<br><img src="/2018/06/19/操作系统复习/图片4.jpg" alt="页表"></li></ol><h4 id="分页存储管理的页面分配算法"><a href="#分页存储管理的页面分配算法" class="headerlink" title="分页存储管理的页面分配算法"></a>分页存储管理的页面分配算法</h4><ol><li>计算本进程需要的总帧数N</li><li>在位示图中查找,若无足够的空间，不能分配</li><li>请求一张PT表</li><li>从位示图中找出N的空闲位，并计算它们的帧号，写入PT表</li><li>修改位示图</li><li>将PT表的起始地址写入进程PCB</li><li>分配结束</li></ol><h4 id="分页存储管理的地址重定位"><a href="#分页存储管理的地址重定位" class="headerlink" title="分页存储管理的地址重定位"></a>分页存储管理的地址重定位</h4><p><code>&lt;页号，页内偏移&gt;</code><br><img src="/2018/06/19/操作系统复习/图片5.jpg" alt=""></p><p><img src="/2018/06/19/操作系统复习/图片6.jpg" alt=""></p><h4 id="分页管理的页面共享"><a href="#分页管理的页面共享" class="headerlink" title="分页管理的页面共享"></a>分页管理的页面共享</h4><p><code>页面共享</code>，指的是一个页面同时供多个进程使用。带来了一个很重要的问题，即用户访问权限问题。<br><code>页面共享</code>比较不易实现</p><h4 id="分页管理的增强管理————快表"><a href="#分页管理的增强管理————快表" class="headerlink" title="分页管理的增强管理————快表"></a>分页管理的增强管理————快表</h4><ol><li>快表存储在cache中</li><li>快表存放最近使用了的页表项</li></ol><p><img src="/2018/06/19/操作系统复习/图片7.jpg" alt=""></p><h3 id="基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算"><a href="#基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算" class="headerlink" title="基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算"></a>基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算</h3><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>将进程的页表按帧的长度划分为多个页面，并建立高一级的页表来索引它们———<code>二级页表</code><br>如果高一级的页表也必须用多个帧来存放，那么还需要建立更高一级的页表———<code>多级页表</code>  </p><p>把整个页表分割成许多小页表，每个称为页表页，它的大小与页框的长度相同，于是每个页表页含有若干个页表表项。页表页从0开始顺序编号，允许被分散存放在不连续的页框中，为了找到页表页，需要建立地址索引，称为页目录表，其表项指出页表页起始地址。系统位每个进程键一张页目录表，它的每个表项指出一个页表项，而页表页的每个表项给出页面和页框的对应关系，<code>页目录表是一级页表</code>，<code>页表页是二级目录</code>，共同构成<code>二级页表机制</code>。</p><p><code>例题</code>：若一个由32位二进制组成的地址空间，页面长度为4KB，每个页表项占用4B，请问地址字结构。<br><code>解</code>：</p><ol><li>因为每个页面长度为4kb，所以，地址的页内偏移为12位。</li><li>所以，地址的页号长度位20位。</li><li>20位的页号可以表示1M个页面。</li><li>因为每个页表项占用4b，所以一个页表的大小是4mb。</li><li>又因为每个页面长度为4kb，所以一个页表需要1k个页面来存放</li><li>每个页面存放1k个页表项<br>所以，地址字结构是<br>前10位放一级页表在二级页表中的地址，中间10位放每个页面在一级页表中的地址，最后12位放页面偏移量<br><img src="/2018/06/19/操作系统复习/图片8.jpg" alt=""></li></ol><h4 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h4><p>基于<code>程序局部性原理</code>，对内存和外存空间，实现<code>部分换入</code>和<code>部分对换</code>功能，为用户提供一个比物理内存大得多，可寻址的<code>内存储器</code></p><h5 id="请求分页虚存管理"><a href="#请求分页虚存管理" class="headerlink" title="请求分页虚存管理"></a>请求分页虚存管理</h5><p>不把所有的作业信息都放入内存（包括程序和数据），仅放入需要立即使用的的页面，在执行过程中遇到没有装入内存的页面，发生缺页中断，在驱动磁盘装入所需要的页面<br>实现方式：<br>增加页表的内存，增加驻存标志位等信息  </p><h6 id="外页表"><a href="#外页表" class="headerlink" title="外页表"></a>外页表</h6><p>为了管理存放在磁盘的页面，操作系统增加了外页表</p><ul><li>记录了页面和磁盘的物理地址的对应信息，进程启动前由操作系统创建</li><li>外页表可以放在磁盘中存储，在发生缺页中断时，外页表才被调入内存。</li></ul><p><img src="/2018/06/19/操作系统复习/图片9.jpg" alt=""></p><h5 id="请求分页虚存管理的优缺点"><a href="#请求分页虚存管理的优缺点" class="headerlink" title="请求分页虚存管理的优缺点"></a>请求分页虚存管理的优缺点</h5><ul><li>优点： 有利于多道程序设计，有利于提高内存利用率，减少碎片</li><li>缺点： 要有硬件支持（MMU：逻辑地址转换物理地址），要有缺页中断处理机制，增大了系统的开销</li></ul><h3 id="基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算"><a href="#基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算" class="headerlink" title="基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算"></a>基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算</h3><h4 id="基本存储管理计算有效访存时间"><a href="#基本存储管理计算有效访存时间" class="headerlink" title="基本存储管理计算有效访存时间"></a>基本存储管理计算有效访存时间</h4><p>设t1为访问一次快表的时间，t2为一次内存访问时间：</p><p>如果一次查询快表能找到所用的页，我们称作命中。此时的有效访存时间t大约为：<br>                        <code>t = t1 + t2</code><br>如果一次查询快表找不到所用的页，称作没有命中。此时的有效访存时间t将是：<br>                        <code>t = t1 + 2*t2</code><br>一般地，当查询快表的命中率为p，则平均内存有效访问时间T大约为：<br>                        <code>T = p*(t1+t2)+(1-p)*(t1+2*t2)</code></p><h4 id="请求分页存储管理的平均访问时间"><a href="#请求分页存储管理的平均访问时间" class="headerlink" title="请求分页存储管理的平均访问时间"></a>请求分页存储管理的平均访问时间</h4><p>设t1位访问一次快表的时间，t2为一次内存访问的时间，t3为缺页处理的时间</p><h5 id="不考虑快表命中率和缺页中断时"><a href="#不考虑快表命中率和缺页中断时" class="headerlink" title="不考虑快表命中率和缺页中断时"></a>不考虑快表命中率和缺页中断时</h5><ol><li>访问的页面在快表中（一定在内存中）:<br> 查找快表的时间+访问内存的时间<br> <code>t = t1 + t2</code></li><li>访问的页面在主存中（不发生缺页中断）:<br> 查找快表的时间+查找页表的时间+访问内存的时间<br> <code>t = t1 + t2 + t2</code></li><li>访问的页面不在主存中（发生缺页中断）：<br> 查找快表的时间+查找页表的时间+中断处理的时间（包括修改快表和页表）+查找快表的时间+访问内存的时间<br> <code>t = t1 + t2 + t3 + t1 + t2</code><h5 id="考虑快表命中率和缺页中断时"><a href="#考虑快表命中率和缺页中断时" class="headerlink" title="考虑快表命中率和缺页中断时"></a>考虑快表命中率和缺页中断时</h5>设快表命中为m，缺页中断率为n<br><code>t = m*(t1 + t2) + (1 - m)*[(1 - n)*(t1 + 2*t2) + n*(2*t1 + 2*t2 + t3)]</code></li></ol><h3 id="缺页从哪儿调入？调入时间分析"><a href="#缺页从哪儿调入？调入时间分析" class="headerlink" title="缺页从哪儿调入？调入时间分析"></a>缺页从哪儿调入？调入时间分析</h3><h3 id="5种页面置换算法的原理和应用"><a href="#5种页面置换算法的原理和应用" class="headerlink" title="5种页面置换算法的原理和应用"></a>5种页面置换算法的原理和应用</h3><ol><li>最佳页面替换算法（OPT）<br> 选择置换下次访问距当前时间最长的那些页。但是程序是不可预知的，所以这种算法是不可实现的，但是可用来衡量其他的各种算法</li><li>先进先出页面替换算法（FIFO）<br> 置换驻留在内存中时间最长的页<br> 思想：一个很久以前取入内存的页，到现在可能已经不会再用到了。<br> 问题：经常出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况。</li><li>最近最久未用的页面替换算法（LRU）<br> 置换内存中上次使用距当前最远的页。根据程序局部性原理，在较长时间里未被使用的页面，可能不会马上使用到。<br> 为每一页添加一个最后一次访问的时间戳，并且必须在每次访问内存时，都要更新时间戳。<br> 维护一个关于访问页的栈。</li><li>时钟Clock算法  <ol><li>简单的时钟替换算法<ul><li>当页面首次被置入时，其<code>引用位</code>置0</li><li>当页面被访问时，<code>引用位</code>置1</li><li>当需要进行页面置换时，扫描以查找<code>引用位</code>为0的页框，当遇到<code>引用位</code>为1的页框，就将它的<code>引用位</code>置0，并跳过这个页面，当遇到<code>引用位</code>为0的页框，就把它置换。</li><li>如果扫描一圈都没有完成置换，指针会停留在起始位置，此时，就把起始位置的页面置换出去。</li></ul><ol><li>时钟策略改进法<br>（把<code>引用位</code>和<code>修改位</code>结合起来使用）</li></ol><ul><li>最近未被引用，也未被修改(u=0,m=0)</li><li>最近被引用，但是未被修改(u=1,m=0)</li><li>最近未被引用，但是被修改(u=0,m=1)</li><li>最近被引用，且被修改(u=1,m=1)<br>算法执行过程</li></ul><ol><li>第一圈扫描，找出(u=0,m=0)的页面，找到就执行置换</li><li>若第1步失败，扫描第2圈，找出(u=0,m=1)的页面，找到就执行置换，在扫描过程中同时把u置0</li><li>若第2步失败，此时所有的页面u=0，再执行第1步，必要时执行第2步，则一定可以找出一个可以置换的算法</li></ol></li></ol></li><li>第二次机会页面替换算法<br>改进FIFO算法，把FIFO算法和<code>引用位结合起来</code></li></ol><ul><li>检查FIFO的队首的<code>引用位</code>,若位0，则这个页面又老又没用，被淘汰。</li><li>如果<code>引用位</code>为1，那么说明该页面进入最早，但是还在使用，把引用为置0，并放入队尾<br>思想：对FIFO算法中最老的页面，若它最近仍在使用，把它看作一个新放入的页面，使他还有几会留在内存中。<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4></li></ul><ol><li>用MAT表记录内存使用情况</li><li>建立段表ST（一个进程一个）</li></ol><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>分段存储管理把进程的逻辑地址空间分成多段，提供二位逻辑地址（段号+段内位移），分段存储管理的实现基于可变分区存储管理原理。分段方式以段位单位来划分和连续存放，为作业的各段分配一个连续的内存空间，而各段之间不一定连续。  </p><p>在地址重定位时，根据段号从段表中找出相应段的起始地址，再加上段内偏移就得出了物理地址</p><h4 id="分段和分页的比较"><a href="#分段和分页的比较" class="headerlink" title="分段和分页的比较"></a>分段和分页的比较</h4><p>分段是信息的<code>逻辑单位</code>，又源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可从任何内存地址开始。在分段方式中，源程序（段号、段内位移）经链接装配后仍保持二维（地址）结构，引入的目的是满足用户模块化程序设计的需要。<br>分页是信息的<code>物理单位</code>，与源程序的逻辑结构无关，是用户不可见的，页长由系统（硬件）确定，页面只能从页大小的整数倍地址开始。在分页方式中，源程序（页号，页内位移）经链接装配后变成一维（地址）结构引入的目的是实现离散分配并提高内存利用率</p><h3 id="第四章课后计算题和应用题"><a href="#第四章课后计算题和应用题" class="headerlink" title="第四章课后计算题和应用题"></a>第四章课后计算题和应用题</h3><h2 id="PartV设备管理与文件管理"><a href="#PartV设备管理与文件管理" class="headerlink" title="PartV设备管理与文件管理"></a>PartV设备管理与文件管理</h2><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p><strong>设备独立性</strong>是指用户作业和物理设备相互独立，用户编写的程序可访问任何设备而无须事先指定物理设备号，即程序中所指定的设备与物理设备无关，逻辑设备名（号）是用户命名的，是更改的，而物理设备号（名）是系统规定的，是不可更改的。<br>设备独立性带来的好处是：  </p><ol><li>应用程序与具体物理设备无关，系统增减或变更设备时，不必对源程序进行修改</li><li>易于应对I/O设备故障，当一个设备故障时，直接使用另一台设备就可以解决</li></ol><ul><li>用户不指定特定设备，指定逻辑设备，使得用户作业和物理设备独立开来</li><li>通过其它途径建立逻辑设备和物理设备之间对应关系，这种特性为“设备独立性”</li><li>好处–用户与物理的外围设备无关，系统增减或变更外围设备时程序不必修改；易于对付输入输出设备的故障。</li></ul><h3 id="缓冲区设置的目的、设置方法、计算"><a href="#缓冲区设置的目的、设置方法、计算" class="headerlink" title="缓冲区设置的目的、设置方法、计算"></a>缓冲区设置的目的、设置方法、计算</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ol><li>减少设备的驱动次数</li><li>减缓I/O操作对缺页置换的干扰</li><li>减缓CPU与I/O设备的速度差距</li></ol><h4 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h4><ul><li>写操作<br>当进程执行写操作输出数据时，先向系统申请一个输出缓冲区，然后将数据送到缓冲区，若是顺序写请求，则不断把数据填到缓冲区，直到装满为止，此后进程可以继续计算，同时，系统将缓冲区内容写到设备上</li><li>读操作<br>当进程执行读操作输入数据时，现象系统申请一个缓冲区，系统将设备上的一条物理记录读至缓冲区，根据要求把当前所需要的逻辑记录从缓冲区选出并传送给进程<h4 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h4></li><li>无缓冲区<br>  <code>T = n * (T输入+T计算)</code></li><li>单缓冲区<br>  <code>T = T输入 + T传输 + (n-1) * MAX(T输入+T传输,T计算) + T计算</code></li><li>双缓冲区<br>  <code>T = T输入 + (n-1) * MAX(T输入,T传输+T计算) + T传输 + T计算</code><h3 id="Unix的缓冲池管理机制"><a href="#Unix的缓冲池管理机制" class="headerlink" title="Unix的缓冲池管理机制"></a>Unix的缓冲池管理机制</h3>缓冲池是系统提供的一种共享结构，不归某个进程所有。任何程序都可以申请缓冲池中的一个存储块，用来存储自己的缓冲数据。</li><li><strong>空闲缓冲队列(emq)</strong>:该队列上挂有所有可用的空闲缓冲区</li><li><strong>输入队列(inq)</strong>:该列队上挂装满输入数据的缓冲区</li><li><strong>输出队列(outq)</strong>:该队列上挂装满输出数据的缓冲区</li></ul><p><img src="/2018/06/19/操作系统复习/图片10.jpg" alt=""></p><h3 id="进行一次磁盘读写所需要的时间的计算"><a href="#进行一次磁盘读写所需要的时间的计算" class="headerlink" title="进行一次磁盘读写所需要的时间的计算"></a>进行一次磁盘读写所需要的时间的计算</h3><h4 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h4><ul><li>寻道时间（t1）：将磁头臂移到目标磁道所用的时间</li><li>旋转延迟时间（t2）：将磁盘带访问的扇区移动到读/写磁头可访问的位置所需要的时间</li><li>传输时间（t3）：读/写操作数据传输所需要的时间</li></ul><p>一次磁盘读取操作是三个操作时间的总和：<br><code>T = t1 + t2 + t3</code></p><ol><li>寻道时间 t1 = s（磁盘启动时间） + m（平均跨越一道的时间） * n（跨越的道数）</li><li>平均旋转延迟时间 t2 = r（旋转速度(转/秒)）/2</li><li>传输时间 t3 = b（要传送的字节数）/N（一个磁道中的字节数） * r（旋转速度）</li></ol><h3 id="4种磁盘调度算法原理及计算"><a href="#4种磁盘调度算法原理及计算" class="headerlink" title="4种磁盘调度算法原理及计算"></a>4种磁盘调度算法原理及计算</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>按请求到来的顺序进行服务<br>优点： 比较公平<br>缺点： 通常不能提供最快的服务</p><h4 id="最短寻道时间优先算法-SSTF"><a href="#最短寻道时间优先算法-SSTF" class="headerlink" title="最短寻道时间优先算法 SSTF"></a>最短寻道时间优先算法 SSTF</h4><p>从当前磁头的位置选择最短寻道时间的请求，即选择和当前磁头位置最近的请求<br>优点： 大大提高了性能<br>缺点： 没考虑磁头转向的时间；有可能出现“粘着”，“饥饿”等现象，即磁头只响应中间位置的请求，对两头位置较远的请求不予理睬</p><h4 id="电梯调度-SCAN"><a href="#电梯调度-SCAN" class="headerlink" title="电梯调度 SCAN"></a>电梯调度 SCAN</h4><p>磁盘臂从磁盘的一端向另一端移动，当磁头经过每个柱面时，处理位于该柱面的请求，当前面已经没有请求了，磁头转向，继续处理<br>优点： 性能比较良好，且不会出现“饥饿”，“粘着”的现象<br>缺点： 需要知道磁头的当前位置和磁头的移动方向；某些请求处理可能不及时（恰好磁头进过它，要等磁头绕一圈回来处理完所有请求）<br><img src="/2018/06/19/操作系统复习/图片11.jpg" alt=""></p><h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><p>SCAN的变种，磁头从一端移动到另一端，随着移动不断处理请求。不过，当磁头移动到另一端时，马上返回，中间不处理请求。</p><h3 id="用户程序发出磁盘I-O请求后，系统一般的处理流程"><a href="#用户程序发出磁盘I-O请求后，系统一般的处理流程" class="headerlink" title="用户程序发出磁盘I/O请求后，系统一般的处理流程"></a>用户程序发出磁盘I/O请求后，系统一般的处理流程</h3><p><strong>用户程序→系统调用处理程序→设备驱动程序→中断处理程序</strong></p><h3 id="文件的4种物理存储结构"><a href="#文件的4种物理存储结构" class="headerlink" title="文件的4种物理存储结构"></a>文件的4种物理存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>将文件中逻辑上连续的信息存放到存储介质的相邻物理块上形成的顺序结构，叫做顺序文件</p><ul><li>优点：  <ol><li>管理简单</li><li>存取速度块</li><li>既合适顺序存储，也合适随机存取</li></ol></li><li>缺点：  <ol><li>外存空间利用率低</li><li>必须预先知道文件长度</li><li>不便于文件的扩展<h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4>连接结构的特点是使用连接字，又称指针，来表示文件中各条记录之间的关系<h5 id="显式链接存储结构"><a href="#显式链接存储结构" class="headerlink" title="显式链接存储结构"></a>显式链接存储结构</h5>将用于链接文件各盘块的指针，“显示”的存放在外存的一张链接表中。该表在整个磁盘仅设置了一张，登记了分配给文件所有盘块的链接关系，故将该表称为<code>文件分配表FAT</code><br><img src="/2018/06/19/操作系统复习/图片12.jpg" alt=""><h5 id="隐式链接存储结构"><a href="#隐式链接存储结构" class="headerlink" title="隐式链接存储结构"></a>隐式链接存储结构</h5>每个文件的FCB中只登记起始盘块和末盘块号，其他盘块号均由链接指针记录。<br><img src="/2018/06/19/操作系统复习/图片13.jpg" alt=""></li></ol></li></ul><h5 id="链式存储的特点"><a href="#链式存储的特点" class="headerlink" title="链式存储的特点"></a>链式存储的特点</h5><ul><li>采用离散分配方式：磁盘上的所有空闲块都可以被利用，消除了外部碎片</li><li>易于文件增长或收缩：当文件需要增长时，可动态分配新盘块，并用指针链接起来，收缩时只要从链中取消不需要的块即可</li><li>指针本身需要存储空间：如果采用隐式存储，磁盘块中需要存储空间。如果采用显示存储，需要为FAT表分配空间</li><li>链接指针的可靠性是个问题：存取文件时，如果哪个指针丢失或错误，指针可能指向其他文件造成不可预估的错误</li></ul><h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><p>为每个文件分配一个索引块，索引块登记了个逻辑块与外存物理块的对应关系，并在文件FCB中登记该文件索引块的地址<br><img src="/2018/06/19/操作系统复习/图片14.jpg" alt=""></p><ul><li>既适合顺序存取，也合适随机存取</li><li>索引结构易实现记录的增、删和插入</li><li>缺点是由于索引表的建立增加了存储空间的开销</li></ul><h5 id="二级索引结构"><a href="#二级索引结构" class="headerlink" title="二级索引结构"></a>二级索引结构</h5><p>将索引表离散存储，即将索引表本身分为若干个逻辑块，存储在若干个物理盘块中，将索引表所占的各盘块号记入另一个索引表————索引表的索引表。这种结构就成为二级索引结构</p><p><img src="/2018/06/19/操作系统复习/图片15.jpg" alt=""></p><h4 id="UNIX混合存储结构"><a href="#UNIX混合存储结构" class="headerlink" title="UNIX混合存储结构"></a>UNIX混合存储结构</h4><p><img src="/2018/06/19/操作系统复习/图片16.jpg" alt=""><br>说明：UNIX操作系统采用了多级混合索引结构（包括直接寻址、一级索引、二级索引和三级索引），规定每个索引结点使用13个地址登记项，其中，前10个登记项直接指出存放文件信息的盘块号，属于直接寻址，第11个登记项指向一级索引块，内涵若干个一级索引存储块。第12个登记项指向二级索引块，第13个登记项指向三级索引块。</p><h3 id="文件目录、文件的索引节点"><a href="#文件目录、文件的索引节点" class="headerlink" title="文件目录、文件的索引节点"></a>文件目录、文件的索引节点</h3><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p>文件目录是一种数据结构，由若干目录项构成，每个目录项对应其中一个文件的FCB(包括文件名、文件体的物理地址、存取控制信息等)，文件体另外存放。文件目录用于检索文件，一般的文件目录包括以下内容：  </p><ol><li>文件存储控制信息，如用户名、文件名、文件类型、文件访问权限（可读可写、只读、只执行等）</li><li>文件结构信息，如文件的逻辑结构，文件的物理结构，文件在存储介质上的位置，文件长度等</li><li>文件管理信息，如文件的建立日期，文件被修改的信息，文件的保留日期和记账信息等</li></ol><h4 id="建立文件目录的主要目的"><a href="#建立文件目录的主要目的" class="headerlink" title="建立文件目录的主要目的"></a>建立文件目录的主要目的</h4><ol><li>实现“按名存取”。用户只需向系统提供所需访问文件的名字，便能快速准确地找到指定文件在外存上的位置。</li><li>提高对目录的检索速度。合理组织目录结构，缩短目录检索所需时间，从而提高文件的存取速度。</li><li>允许文件共享。多用户系统中，允许多个用户共享同一个物理文件，以节约外存空间。</li><li>允许文件重名。用户可按照自己的习惯给自己的文件命名，不必担心是否会跟别的用户文件重名。<h4 id="文件索引结点"><a href="#文件索引结点" class="headerlink" title="文件索引结点"></a>文件索引结点</h4>由于文件的FCB信息较大，需要的存储空间较大，所以查找一次文件需要的时间比较多，为了解决这种情况，就引入了文件索引结点</li></ol><p>索引结点是将文件名和文件信息分开记录，将文件的描述信息单独形成一个称为索引结点的数据结构</p><p>在unix中，索引结点称为i结点，一个目录项仅占16个字节，其中14个字节为文件名，2个字节为结点号。</p><h3 id="Unix、Linux空闲盘块成组链接组织方式"><a href="#Unix、Linux空闲盘块成组链接组织方式" class="headerlink" title="Unix、Linux空闲盘块成组链接组织方式"></a>Unix、Linux空闲盘块成组链接组织方式</h3><h3 id="第五、六章课后计算题和应用题"><a href="#第五、六章课后计算题和应用题" class="headerlink" title="第五、六章课后计算题和应用题"></a>第五、六章课后计算题和应用题</h3><p>总：回顾整个操作系统各个功能模块的功能及功能实现有关的数据结构和算法</p><pre><code>按照复习提纲，结合课本、课件、课堂例题、课后作业题进行复习，特别是各章节授课过程中讲过的例题和各章习题，必须掌握其解题思路和方法。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2018年春季学期计算机操作系统原理复习提纲&quot;&gt;&lt;a href=&quot;#2018年春季学期计算机操作系统原理复习提纲&quot; class=&quot;headerlink&quot; title=&quot;2018年春季学期计算机操作系统原理复习提纲&quot;&gt;&lt;/a&gt;2018年春季学期计算机操作系统原理复习提纲&lt;/h1&gt;&lt;p&gt;（包括基本概念、管理原理、计算和综合应用）&lt;/p&gt;
    
    </summary>
    
      <category term="复习总结" scheme="https://734432041.github.io/categories/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="复习" scheme="https://734432041.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://734432041.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>『小白日记』join函数学习笔记</title>
    <link href="https://734432041.github.io/2018/06/12/%E3%80%8E%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%E3%80%8Fjoin%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://734432041.github.io/2018/06/12/『小白日记』join函数学习笔记/</id>
    <published>2018-06-12T08:41:13.000Z</published>
    <updated>2018-06-12T08:47:35.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="join函数"><a href="#join函数" class="headerlink" title="join函数"></a>join函数</h1><p><code>join</code>函数，用于连接字符集，生成字符串<br>原型：<code>&#39;sep&#39;.join(seq)</code><br>Sep：用于分割字符串的分隔符<br>Seq：需要连接的字符集<br>意义：用sep将seq中的元素连接。<br>Seq可以是<code>列表</code>，<code>字典</code>，<code>元组</code>，<code>字符串集</code><br>返回值：一个连接好的字符串<br><a id="more"></a></p><p>实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分隔符</span></span><br><span class="line">`sep = <span class="string">"-"</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#list</span></span><br><span class="line">list = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>]</span><br><span class="line">str = sep.join(list)</span><br><span class="line">print(str)</span><br><span class="line"><span class="comment"># output:a-b-c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#dict</span></span><br><span class="line">dict = &#123;<span class="string">'d'</span>:<span class="number">1</span>,<span class="string">'e'</span>:<span class="number">2</span> ,<span class="string">'f'</span>:<span class="number">3</span>&#125;</span><br><span class="line">str = sep.join(dict)</span><br><span class="line">print(str)</span><br><span class="line"><span class="comment">#output: d-e-f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#srting</span></span><br><span class="line">string = <span class="string">"ghi"</span></span><br><span class="line">str = sep.join(string)</span><br><span class="line">print(str)</span><br><span class="line"><span class="comment">#output: g-h-i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tuple</span></span><br><span class="line">tuple = (<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>)</span><br><span class="line">str = sep.join(tuple)</span><br><span class="line">print(str)</span><br><span class="line"><span class="comment">#output: j-k-l</span></span><br></pre></td></tr></table></figure></p><h1 id="join的一些代码段"><a href="#join的一些代码段" class="headerlink" title="join的一些代码段"></a>join的一些代码段</h1><p>#迷宫<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    print(<span class="string">""</span>.join(random.choice([<span class="string">'/'</span>,<span class="string">'\\'</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">40</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment"># //\/\//\\//\/\/////\/////\///\\\\\\/\/\/</span></span><br><span class="line"><span class="comment"># /\\/\/\//\/////\/\/\///\\/\\\\/\/\\\\\/\</span></span><br><span class="line"><span class="comment"># /\/\/\/\\//\\//\//\/\//\/\//\\//\//\\\\\</span></span><br><span class="line"><span class="comment"># /\/\/\/\/\\/\\\\/////\\/\\\/\\/\\/\\\//\</span></span><br><span class="line"><span class="comment"># /\/\\////\//////\\//\///\\//\//////\\//\</span></span><br><span class="line"><span class="comment"># \/\/\//\\\/\\\///\\\/\\\\//\/\////\\///\</span></span><br><span class="line"><span class="comment"># \\/\\\\\//\/\\/\\////\\\/\\\///\\//\\///</span></span><br><span class="line"><span class="comment"># ///\\\\\\\\//\\/\/\//\\\/\\///\\\\//\///</span></span><br><span class="line"><span class="comment"># \\\/\/\/\/\\///\\\\/\\///\/\//\\////\/\/</span></span><br><span class="line"><span class="comment"># \//\\/\//\\/\\/\////\\/\\\/\\\\//\//\//\</span></span><br><span class="line"><span class="comment"># \/\/\\/\\\//\////\\\//\/\\/\\///////\\\\</span></span><br><span class="line"><span class="comment"># /\//\\\\\\/\//\/\/\/\\\///\\\\\\////////</span></span><br><span class="line"><span class="comment"># //\//\/\\\/\\/\\\\\/\//\///\\\//\\\///\\</span></span><br><span class="line"><span class="comment"># /\\///\\\//\/\////\/\/\//\/\\\\/\//\\//\</span></span><br><span class="line"><span class="comment"># /\//\/\/\\/\/\/\\/\\/\/\\\\\\\/\/\////\/</span></span><br><span class="line"><span class="comment"># \\/\/\\\\\\////\///\\/\\//\\///\//\//\\\</span></span><br><span class="line"><span class="comment"># //\/\/\\/\\/\\\/\//\/\////\///\\\////\\\</span></span><br><span class="line"><span class="comment"># \//////\/\\\/\\////\///\\\\\//\/\\\\/\//</span></span><br><span class="line"><span class="comment"># \\////\\///\/\//\/\///\\\\\/\\\\\\\\//\\</span></span><br><span class="line"><span class="comment"># //\/\///\\\\//\\\\\\////\/\\\///\/\/\/\/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">' '</span>.join(str(i)+<span class="string">'*'</span>+str(j)+<span class="string">'='</span>+str(i*j) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>)))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment"># 1*1=1</span></span><br><span class="line"><span class="comment"># 2*1=2 2*2=4</span></span><br><span class="line"><span class="comment"># 3*1=3 3*2=6 3*3=9</span></span><br><span class="line"><span class="comment"># 4*1=4 4*2=8 4*3=12 4*4=16</span></span><br><span class="line"><span class="comment"># 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25</span></span><br><span class="line"><span class="comment"># 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36</span></span><br><span class="line"><span class="comment"># 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49</span></span><br><span class="line"><span class="comment"># 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64</span></span><br><span class="line"><span class="comment"># 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/06/12/『小白日记』join函数学习笔记/6ac06196c033986e0699549709a80779f2b6c2b572629-vIkQ5d_fw658.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;join函数&quot;&gt;&lt;a href=&quot;#join函数&quot; class=&quot;headerlink&quot; title=&quot;join函数&quot;&gt;&lt;/a&gt;join函数&lt;/h1&gt;&lt;p&gt;&lt;code&gt;join&lt;/code&gt;函数，用于连接字符集，生成字符串&lt;br&gt;原型：&lt;code&gt;&amp;#39;sep&amp;#39;.join(seq)&lt;/code&gt;&lt;br&gt;Sep：用于分割字符串的分隔符&lt;br&gt;Seq：需要连接的字符集&lt;br&gt;意义：用sep将seq中的元素连接。&lt;br&gt;Seq可以是&lt;code&gt;列表&lt;/code&gt;，&lt;code&gt;字典&lt;/code&gt;，&lt;code&gt;元组&lt;/code&gt;，&lt;code&gt;字符串集&lt;/code&gt;&lt;br&gt;返回值：一个连接好的字符串&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://734432041.github.io/categories/python/"/>
    
    
      <category term="学习笔记" scheme="https://734432041.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://734432041.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>『小白日记』lambda学习笔记</title>
    <link href="https://734432041.github.io/2018/06/12/%E3%80%8E%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%E3%80%8Flambda%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://734432041.github.io/2018/06/12/『小白日记』lambda学习笔记/</id>
    <published>2018-06-12T05:23:23.000Z</published>
    <updated>2018-06-12T05:30:53.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda的学习笔记"><a href="#Lambda的学习笔记" class="headerlink" title="Lambda的学习笔记"></a>Lambda的学习笔记</h1><a id="more"></a><h2 id="lambda函数，也是匿名函数，即一个没有名字的函数"><a href="#lambda函数，也是匿名函数，即一个没有名字的函数" class="headerlink" title="lambda函数，也是匿名函数，即一个没有名字的函数"></a>lambda函数，也是匿名函数，即一个没有名字的函数</h2><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun = <span class="keyword">lambda</span> x:x**<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(fun(i))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(pow(i))</span><br></pre></td></tr></table></figure><p>这里，<code>fun</code>是<code>lambda</code>定义的一个表达式，<code>x</code>是匿名参数入口参数，<code>x+1</code>是匿名函数的函数体。使用<code>lambda</code>可以是代码更清楚。</p><h2 id="Lambda语法实际上是构建了一个函数对象"><a href="#Lambda语法实际上是构建了一个函数对象" class="headerlink" title="Lambda语法实际上是构建了一个函数对象"></a>Lambda语法实际上是构建了一个函数对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun = <span class="keyword">lambda</span> x:x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(fun)</span><br><span class="line"><span class="comment">#输出结果：&lt;function &lt;lambda&gt; at 0x0000017CE2E6D6A8&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Python中三个定义好的全局函数"><a href="#Python中三个定义好的全局函数" class="headerlink" title="Python中三个定义好的全局函数"></a>Python中三个定义好的全局函数</h2><ul><li><p>Filter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(list(filter(<span class="keyword">lambda</span> x:x%<span class="number">3</span>==<span class="number">0</span> , test1)))</span><br><span class="line"><span class="comment">#[0, 3, 6, 9]</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> test1 <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>])</span><br><span class="line"><span class="comment">#[0, 3, 6, 9]</span></span><br></pre></td></tr></table></figure></li><li><p>Map</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>+<span class="number">10</span> , test1)))</span><br><span class="line"><span class="comment">#[10, 11, 14, 19, 26, 35, 46, 59, 74, 91]</span></span><br><span class="line">print([x**<span class="number">2</span>+<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> test1])</span><br><span class="line"><span class="comment">#[10, 11, 14, 19, 26, 35, 46, 59, 74, 91]</span></span><br></pre></td></tr></table></figure></li><li><p>Reduce<br><code>reduce()</code> 函数会对参数序列中元素进行累积。</p></li></ul><p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 <code>reduce</code> 中的函数 <code>function</code>（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 <code>function</code> 函数运算，最后得到一个结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">print(reduce(<span class="keyword">lambda</span> x,y:x+y,test1))</span><br><span class="line"><span class="comment">#输出结果：45</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/06/12/『小白日记』lambda学习笔记/f3a795011b6d40790106be979fc759335f0c1a0a4cf5-eqFXCt_fw658.jpg" alt="安装"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lambda的学习笔记&quot;&gt;&lt;a href=&quot;#Lambda的学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Lambda的学习笔记&quot;&gt;&lt;/a&gt;Lambda的学习笔记&lt;/h1&gt;
    
    </summary>
    
      <category term="python" scheme="https://734432041.github.io/categories/python/"/>
    
    
      <category term="学习笔记" scheme="https://734432041.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="python" scheme="https://734432041.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客迁移到另一台电脑</title>
    <link href="https://734432041.github.io/2018/06/11/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8F%A6%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91/"/>
    <id>https://734432041.github.io/2018/06/11/hexo博客迁移到另一台电脑/</id>
    <published>2018-06-11T09:28:22.000Z</published>
    <updated>2018-06-11T11:04:06.094Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拷贝原来电脑上hexo目录的一下文件"><a href="#拷贝原来电脑上hexo目录的一下文件" class="headerlink" title="拷贝原来电脑上hexo目录的一下文件"></a>拷贝原来电脑上hexo目录的一下文件</h1><ul><li>config.yml</li><li>package.json</li><li>scaffolds/</li><li>source/</li><li>themes/</li></ul><a id="more"></a><h1 id="在新电脑上安装node-js"><a href="#在新电脑上安装node-js" class="headerlink" title="在新电脑上安装node.js"></a>在新电脑上安装node.js</h1><p><a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a> </p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p><a href="https://gitforwindows.org/" target="_blank" rel="noopener">git</a></p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p><code>npm install -g hexo</code></p><h1 id="在hexo目录下执行以下命令"><a href="#在hexo目录下执行以下命令" class="headerlink" title="在hexo目录下执行以下命令"></a>在hexo目录下执行以下命令</h1><p><code>npm install</code><br><code>npm install hexo-deployer-git –save</code><br><code>npm install hexo-generator-feed –save</code><br><code>npm install hexo-generator-sitemap –save</code></p><h1 id="填写git信息"><a href="#填写git信息" class="headerlink" title="填写git信息"></a>填写git信息</h1><p><code>git config --global user.email &quot;you@example.com&quot;</code><br><code>git config --global user.name &quot;Your Name&quot;</code><br><img src="/2018/06/11/hexo博客迁移到另一台电脑/Snipaste_2018-06-10_23-45-26.png" alt=""></p><h1 id="填写你的GitHub账号"><a href="#填写你的GitHub账号" class="headerlink" title="填写你的GitHub账号"></a>填写你的GitHub账号</h1><p><img src="/2018/06/11/hexo博客迁移到另一台电脑/Snipaste_2018-06-10_23-46-21.png" alt=""></p><h1 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h1><p><code>hexo g</code><br><code>hexo s</code></p><h1 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h1><p><img src="/2018/06/11/hexo博客迁移到另一台电脑/a269e2a43bb35529872a3d52f8a11805899217be40780-cvfXDk_fw658.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;拷贝原来电脑上hexo目录的一下文件&quot;&gt;&lt;a href=&quot;#拷贝原来电脑上hexo目录的一下文件&quot; class=&quot;headerlink&quot; title=&quot;拷贝原来电脑上hexo目录的一下文件&quot;&gt;&lt;/a&gt;拷贝原来电脑上hexo目录的一下文件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;config.yml&lt;/li&gt;
&lt;li&gt;package.json&lt;/li&gt;
&lt;li&gt;scaffolds/&lt;/li&gt;
&lt;li&gt;source/&lt;/li&gt;
&lt;li&gt;themes/&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="搭建博客" scheme="https://734432041.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://734432041.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://734432041.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>python3配置selenium和chromedriver</title>
    <link href="https://734432041.github.io/2018/06/05/python3%E9%85%8D%E7%BD%AEselenium%E5%92%8Cchromedriver/"/>
    <id>https://734432041.github.io/2018/06/05/python3配置selenium和chromedriver/</id>
    <published>2018-06-05T14:24:41.000Z</published>
    <updated>2018-06-08T15:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python3配置selenium和chromedriver"><a href="#python3配置selenium和chromedriver" class="headerlink" title="python3配置selenium和chromedriver"></a>python3配置selenium和chromedriver</h1><h2 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h2><p>安装selenium<br><img src="/2018/06/05/python3配置selenium和chromedriver/安装.png" alt="安装"><br>用<code>pip list</code>查看是否安装成功</p><h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p>下载<code>chromedriver</code><strong>（注意chromedriver要和chrome版本对应）</strong>  具体的对应可以百度<br><a id="more"></a></p><h2 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h2><p>打开<code>chrome</code>安装地址，可以找到chrome快捷方式，找到目标地址<br><img src="/2018/06/05/python3配置selenium和chromedriver/目标地址.png" alt="目标地址"><br>并把<code>chromedriver.exe</code>移动进去<br><img src="/2018/06/05/python3配置selenium和chromedriver/chromedriver移入.png" alt="移动"></p><h2 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h2><p><strong>添加环境变量</strong><br>此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;添加chrome的安装地址<br><img src="/2018/06/05/python3配置selenium和chromedriver/添加环境变量.png" alt="添加环境变量"></p><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步:"></a>第五步:</h2><p>创建<code>seleniumTest.py</code>文件<br>输入以下代码并执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver=webdriver.Chrome(executable_path=<span class="string">r'你的chrome安装地址\chromedriver.exe'</span>)</span><br><span class="line">driver.get(<span class="string">"http://baidu.com"</span>)</span><br><span class="line">print(driver.title)</span><br></pre></td></tr></table></figure></p><p>弹出百度页面</p><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><p>我的程序是<br><img src="/2018/06/05/python3配置selenium和chromedriver/程序.png" alt="程序"></p><p><img src="/2018/06/05/python3配置selenium和chromedriver/24a9e6f844aa3617cf9986e0f9ef02abb4bfc30a23031-8e1QMN_fw658.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python3配置selenium和chromedriver&quot;&gt;&lt;a href=&quot;#python3配置selenium和chromedriver&quot; class=&quot;headerlink&quot; title=&quot;python3配置selenium和chromedriver&quot;&gt;&lt;/a&gt;python3配置selenium和chromedriver&lt;/h1&gt;&lt;h2 id=&quot;第一步：&quot;&gt;&lt;a href=&quot;#第一步：&quot; class=&quot;headerlink&quot; title=&quot;第一步：&quot;&gt;&lt;/a&gt;第一步：&lt;/h2&gt;&lt;p&gt;安装selenium&lt;br&gt;&lt;img src=&quot;/2018/06/05/python3配置selenium和chromedriver/安装.png&quot; alt=&quot;安装&quot;&gt;&lt;br&gt;用&lt;code&gt;pip list&lt;/code&gt;查看是否安装成功&lt;/p&gt;
&lt;h2 id=&quot;第二步：&quot;&gt;&lt;a href=&quot;#第二步：&quot; class=&quot;headerlink&quot; title=&quot;第二步：&quot;&gt;&lt;/a&gt;第二步：&lt;/h2&gt;&lt;p&gt;下载&lt;code&gt;chromedriver&lt;/code&gt;&lt;strong&gt;（注意chromedriver要和chrome版本对应）&lt;/strong&gt;  具体的对应可以百度&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://734432041.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://734432041.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="selenium" scheme="https://734432041.github.io/tags/selenium/"/>
    
      <category term="chromedriver" scheme="https://734432041.github.io/tags/chromedriver/"/>
    
  </entry>
  
  <entry>
    <title>『小白日记』itchat库学习笔记（一）</title>
    <link href="https://734432041.github.io/2018/06/04/%E3%80%8E%E5%B0%8F%E7%99%BD%E6%97%A5%E8%AE%B0%E3%80%8Fitchat%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://734432041.github.io/2018/06/04/『小白日记』itchat库学习笔记（一）/</id>
    <published>2018-06-04T15:21:19.000Z</published>
    <updated>2018-06-19T09:39:52.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-itchar库的学习笔记（一）"><a href="#Python-itchar库的学习笔记（一）" class="headerlink" title="Python itchar库的学习笔记（一）"></a>Python itchar库的学习笔记（一）</h1><p><a href="http://itchat.readthedocs.io/zh/latest/" target="_blank" rel="noopener">itchat文档</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Pip install itchat  </p><p><img src="/2018/06/04/『小白日记』itchat库学习笔记（一）/安装.png" alt="安装"></p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="登录微信"><a href="#登录微信" class="headerlink" title="登录微信"></a>登录微信</h3><p><code>Itchat.auto_login()</code>，使用这种方式不会保持登录状态，也就是说，下次还需要重新扫描二维码，可以加上hotReload=True 参数使得保持登录状态，该参数产生一个静态文件<code>itchat.pkl</code> 存储登录状态。  </p><p><img src="/2018/06/04/『小白日记』itchat库学习笔记（一）/login.png" alt="安装"></p><h3 id="登录成功"><a href="#登录成功" class="headerlink" title="登录成功"></a>登录成功</h3><p><img src="/2018/06/04/『小白日记』itchat库学习笔记（一）/登陆成功.png" alt="安装"></p><h3 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h3><p><img src="/2018/06/04/『小白日记』itchat库学习笔记（一）/登出.png" alt="安装"></p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p><code>Send(msg=”Text Message”,toUserName)</code>  </p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>Msg：要发送的信息</li><li>发送文件：msg=‘@fil@path_to_file’</li><li>发生图片：msg=’@img@path_to_img’</li><li>发送视频：msg=’@vid@path_to_vid’</li><li>toUserName：发送对象，默认为自己</li><li>返回值： True|False</li></ul><h3 id="注册消息方法"><a href="#注册消息方法" class="headerlink" title="注册消息方法"></a>注册消息方法</h3><p>如果itchat接收到没有注册的消息，消息就会被自动舍弃，但是我们可以自己动态注册消息。  </p><h3 id="自动回复好友实例"><a href="#自动回复好友实例" class="headerlink" title="自动回复好友实例"></a>自动回复好友实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itchat</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">@itchat.msg_register(TEXT,isGroupChat = False)      #表示接受消息时自动执行此函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    msg_content = msg[<span class="string">'Text'</span>]</span><br><span class="line">    itchat.send(<span class="string">"已收到了消息：&#123;&#125;"</span>.format(msg_content),toUserName=msg[<span class="string">'FromUserName'</span>])</span><br><span class="line">    localtime = datetime.datetime.now()</span><br><span class="line">    now_time_str = localtime.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"接收时间为：&#123;&#125;，请耐心等待我的回复"</span>.format(now_time_str)</span><br><span class="line"></span><br><span class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)</span><br><span class="line">itchat.run()</span><br></pre></td></tr></table></figure><p><img src="/2018/06/04/『小白日记』itchat库学习笔记（一）/7e56992740978acf4c23e71353df38e1e8ea9327277f8-g62vLO_fw658.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-itchar库的学习笔记（一）&quot;&gt;&lt;a href=&quot;#Python-itchar库的学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Python itchar库的学习笔记（一）&quot;&gt;&lt;/a&gt;Python itchar库的学习笔记（一）&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://itchat.readthedocs.io/zh/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;itchat文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;Pip install itchat  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/06/04/『小白日记』itchat库学习笔记（一）/安装.png&quot; alt=&quot;安装&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://734432041.github.io/categories/python/"/>
    
    
      <category term="学习笔记" scheme="https://734432041.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Python" scheme="https://734432041.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>基础练习 完美的代价</title>
    <link href="https://734432041.github.io/2018/06/03/%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <id>https://734432041.github.io/2018/06/03/基础练习-完美的代价/</id>
    <published>2018-06-03T13:56:48.000Z</published>
    <updated>2018-06-03T14:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础练习-完美的代价"><a href="#基础练习-完美的代价" class="headerlink" title="基础练习 完美的代价"></a>基础练习 完美的代价</h1><p>时间限制：1.0s   内存限制：512.0MB</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。<br>交换的定义是：交换两个相邻的字符<br>例如mamad<br>第一次交换 ad : mamda<br>第二次交换 md : madma<br>第三次交换 ma : madam (回文！完美！)</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　第一行是一个整数N，表示接下来的字符串的长度(N &lt;= 8000)<br>第二行是一个字符串，长度为N.只包含小写字母</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　如果可能，输出最少的交换次数。<br>    否则输出Impossible<br><a id="more"></a></p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>mamad</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>3</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先分析不可能的情况  </p><ol><li>当字符串长度为奇数，且有至少两个字符为奇数个数</li><li>当字符串长度为偶数，且有至少一个字符为奇数个数</li></ol><p>在可能的情况下的交换方法<br>定义i从左向右遍历，j从右向左遍历，如果str[i]==str[j]说明i和j位置对应，将j移动到字符串的末尾，下次遍历从这次的j的前一个位置开始遍历就好。<br>若n为奇数，且遍历到字符个数为奇数的个数时，只计算这个字符到字符串中间，不用在字符串中交换，这是因为有两个偶数个数的字符在字符串中间的一边是会交换两次。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;end; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = end; j &gt;= i; j--)&#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)&#123;<span class="comment">//从后向前没有找到和str[i]一样的字符 </span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//如果字符个数为偶数，不能出现不配对字符     </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;<span class="comment">//如果字符个数为奇数，且已经出现了奇数个数的字符 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>; </span><br><span class="line">ans += <span class="built_in">abs</span>((n / <span class="number">2</span>) - i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (str[i] == str[j])&#123;<span class="comment">//如果找到配对字符串，把靠后的字符换到末尾，也就是和i对称的位置 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tmp = j; tmp&lt;end; tmp++)&#123;</span><br><span class="line">swap(str[tmp], str[tmp + <span class="number">1</span>]);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">end--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/06/03/基础练习-完美的代价/QQ图片20180603223544.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础练习-完美的代价&quot;&gt;&lt;a href=&quot;#基础练习-完美的代价&quot; class=&quot;headerlink&quot; title=&quot;基础练习 完美的代价&quot;&gt;&lt;/a&gt;基础练习 完美的代价&lt;/h1&gt;&lt;p&gt;时间限制：1.0s   内存限制：512.0MB&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。&lt;br&gt;交换的定义是：交换两个相邻的字符&lt;br&gt;例如mamad&lt;br&gt;第一次交换 ad : mamda&lt;br&gt;第二次交换 md : madma&lt;br&gt;第三次交换 ma : madam (回文！完美！)&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h2&gt;&lt;p&gt;　　第一行是一个整数N，表示接下来的字符串的长度(N &amp;lt;= 8000)&lt;br&gt;第二行是一个字符串，长度为N.只包含小写字母&lt;/p&gt;
&lt;h2 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h2&gt;&lt;p&gt;　　如果可能，输出最少的交换次数。&lt;br&gt;    否则输出Impossible&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://734432041.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥" scheme="https://734432041.github.io/tags/%E8%93%9D%E6%A1%A5/"/>
    
      <category term="题解" scheme="https://734432041.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="C/C++" scheme="https://734432041.github.io/tags/C-C/"/>
    
      <category term="算法训练" scheme="https://734432041.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>2018蓝桥国赛b组题解</title>
    <link href="https://734432041.github.io/2018/06/01/2018%E8%93%9D%E6%A1%A5%E5%9B%BD%E8%B5%9Bb%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <id>https://734432041.github.io/2018/06/01/2018蓝桥国赛b组题解/</id>
    <published>2018-06-01T15:43:00.000Z</published>
    <updated>2018-06-08T15:19:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><h2 id="标题：换零钞"><a href="#标题：换零钞" class="headerlink" title="标题：换零钞"></a>标题：换零钞</h2><p>x星球的钞票的面额只有：100元，5元，2元，1元，共4种。<br>小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。<br>小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，<br>剩下的当然都是5元面额的。</p><p>银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？<br>（5元，2元，1元面额的必须都有，不能是0）</p><p>注意，需要提交的是一个整数，不要填写任何多余的内容。</p><a id="more"></a><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>由于2元数量是1元数量的10倍，所以1元和2元数量只能是21的倍数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">40</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">21</span>*i+k*<span class="number">5</span>==<span class="number">200</span>)&#123;</span><br><span class="line">ans = min(ans,i*<span class="number">11</span>+k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><h2 id="标题：激光样式"><a href="#标题：激光样式" class="headerlink" title="标题：激光样式"></a>标题：激光样式</h2><p>x星球的盛大节日为增加气氛，用30台机光器一字排开，向太空中打出光柱。<br>安装调试的时候才发现，不知什么原因，相邻的两台激光器不能同时打开！<br>国王很想知道，在目前这种bug存在的情况下，一共能打出多少种激光效果？<br>显然，如果只有3台机器，一共可以成5种样式，即：<br>全都关上（sorry, 此时无声胜有声，这也算一种）<br>开一台，共3种<br>开两台，只1种</p><p>30台就不好算了，国王只好请你帮忙了。</p><p>要求提交一个整数，表示30台激光器能形成的样式种数。</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>定义一个数组a[35]表示有i台机器时的样式种数。<br>一台机器有两种，<strong>开</strong>或者<strong>关</strong><br>两台机器有三种，<strong>全关</strong>、<strong>开第一台</strong>或者<strong>开第二台</strong>。<br>三台机器的时候，对第三台机器有开和不开两种。</p><ul><li>当它打开时，第二台一定是关闭的，此时有a[1]种。</li><li>当它关闭时，第一、第二台可能打开也可能关闭，此时有a[2]种<br>得到a[3]=a[1]+a[2]<br>以此类推<br>a[4]=a[3]+a[2];<br>a[5]=a[4]+a[3];<br>。。。。。。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">35</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line">a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[<span class="number">30</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><h2 id="标题：格雷码"><a href="#标题：格雷码" class="headerlink" title="标题：格雷码"></a>标题：格雷码</h2><p>格雷码是以n位的二进制来表示数。<br>与普通的二进制表示不同的是，它要求相邻两个数字只能有1个数位不同。<br>首尾两个数字也要求只有1位之差。</p><p>有很多算法来生成格雷码。以下是较常见的一种：<br>从编码全0开始生成。<br>当产生第奇数个数时，只把当前数字最末位改变（0变1，1变0）<br>当产生第偶数个数时，先找到最右边的一个1，把它左边的数字改变。<br>用这个规则产生的4位格雷码序列如下：<br>0000<br>0001<br>0011<br>0010<br>0110<br>0111<br>0101<br>0100<br>1100<br>1101<br>1111<br>1110<br>1010<br>1011<br>1001<br>1000</p><p>以下是实现代码，仔细分析其中逻辑，并填写划线部分缺少的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> msk = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) msk = msk &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>((a &amp; msk)? <span class="string">"1"</span> : <span class="string">"0"</span>);</span><br><span class="line">msk = msk &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) num = num&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">show(a,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">a = a ^ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a = _________________________ ; <span class="comment">//填空</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="答案：a-a-amp-a-lt-lt-1"><a href="#答案：a-a-amp-a-lt-lt-1" class="headerlink" title="答案：a ^ (((a&amp;(-a))&lt;&lt;1))"></a>答案：a ^ (((a&amp;(-a))&lt;&lt;1))</h3><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>树状数组的<code>lowbit</code>，根据题意，先找到最右边的一个1，把它左边的数字改变，<code>lowbit(x)</code>表示二进制表达式中最低位的一所对应的值，只需要把这个值左移一位，就得到题中的要求了。</p><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><h2 id="标题：调手表"><a href="#标题：调手表" class="headerlink" title="标题：调手表"></a>标题：调手表</h2><p>小明买了块高端大气上档次的电子手表，他正准备调时间呢。<br>在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 n 分钟。<br>大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 0 ，那么按一下按钮就会变成 1，再按一次变成 2 。如果当前的数是 n - 1，按一次后会变成 0 。<br>作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多1，则要按 n - 1 次加一按钮才能调回正确时间。<br>小明想，如果手表可以再添加一个按钮，表示把当前的数加 k 该多好啊……<br>他想知道，如果有了这个 +k 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。<br>注意，按 +k 按钮时，如果加k后数字超过n-1,则会对n取模。<br>比如，n=10, k=6 的时候，假设当前时间是0，连按2次 +k 按钮，则调为2。</p><ul><li>「输入格式」<br>一行两个整数 n, k ，意义如题。</li></ul><ul><li>「输出格式」<br>一行一个整数<br>表示：按照最优策略按键，从一个时间调到另一个时间最多要按多少次。</li></ul><ul><li>「样例输入」<br>5 3</li></ul><ul><li>「样例输出」<br>2</li></ul><ul><li>「样例解释」<br>如果时间正确则按0次。否则要按的次数和操作系列之间的关系如下：<br>1：+1<br>2：+1, +1<br>3：+3<br>4：+3, +1</li></ul><ul><li>「数据范围」<br>对于 30% 的数据 0 &lt; k &lt; n &lt;= 5<br>对于 60% 的数据 0 &lt; k &lt; n &lt;= 100<br>对于 100% 的数据 0 &lt; k &lt; n &lt;= 100000</li></ul><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>因为任意两个点要移动的次数只和他们之间的距离有关系，所以只用计算从0到各个点需要移动的次数就可以了。基本思路就是广搜，从0次开始，判断每次可以移动到的位置，到所有位置都搜索完成。</p><ol><li><p>数组实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">-1</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==t)&#123;</span><br><span class="line">a[(i+<span class="number">1</span>)%n]=t+<span class="number">1</span>;</span><br><span class="line">a[(i+k)%n]=t+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nmax = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line"><span class="keyword">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">int</span> vis[nmax]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> time[nmax]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(time,<span class="number">0</span>,<span class="keyword">sizeof</span>(time));</span><br><span class="line">node now,nxt;</span><br><span class="line">now.time = <span class="number">0</span>;</span><br><span class="line">now.step = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">vis[now.time] = <span class="number">1</span>;</span><br><span class="line">time[now.time]= now.step;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">nxt.time = (now.time+<span class="number">1</span>)%n;</span><br><span class="line"><span class="keyword">if</span>(vis[nxt.time]!=<span class="number">1</span>)&#123;</span><br><span class="line">vis[nxt.time] =<span class="number">1</span>;</span><br><span class="line">nxt.step = now.step+<span class="number">1</span>;</span><br><span class="line">time[nxt.time]=nxt.step;</span><br><span class="line">q.push(nxt);</span><br><span class="line">&#125;</span><br><span class="line">nxt.time = (now.time+k)%n;</span><br><span class="line"><span class="keyword">if</span>(vis[nxt.time]!=<span class="number">1</span>)&#123;</span><br><span class="line">vis[nxt.time]=<span class="number">1</span>;</span><br><span class="line">nxt.step = now.step+<span class="number">1</span>;</span><br><span class="line">time[nxt.time]=nxt.step;</span><br><span class="line">q.push(nxt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">bfs();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ans = max(ans,time[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h1><h2 id="标题：搭积木"><a href="#标题：搭积木" class="headerlink" title="标题：搭积木"></a>标题：搭积木</h2><p>小明对搭积木非常感兴趣。他的积木都是同样大小的正立方体。<br>在搭积木时，小明选取 m 块积木作为地基，将他们在桌子上一字排开，中间不留空隙，并称其为第0层。<br>随后，小明可以在上面摆放第1层，第2层，……，最多摆放至第n层。摆放积木必须遵循三条规则：</p><p>规则1：每块积木必须紧挨着放置在某一块积木的正上方，与其下一层的积木对齐；<br>规则2：同一层中的积木必须连续摆放，中间不能留有空隙；<br>规则3：小明不喜欢的位置不能放置积木。</p><p>其中，小明不喜欢的位置都被标在了图纸上。图纸共有n行，从下至上的每一行分别对应积木的第1层至第n层。每一行都有m个字符，字符可能是‘.’或‘X’，其中‘X’表示这个位置是小明不喜欢的。<br>现在，小明想要知道，共有多少种放置积木的方案。他找到了参加蓝桥杯的你来帮他计算这个答案。<br>由于这个答案可能很大，你只需要回答这个答案对1000000007(十亿零七)取模后的结果。<br>注意：地基上什么都不放，也算作是方案之一种。</p><ul><li>【输入格式】<br>输入数据的第一行有两个正整数n和m，表示图纸的大小。<br>随后n行，每行有m个字符，用来描述图纸 。每个字符只可能是‘.’或‘X’。</li></ul><ul><li>【输出格式】<br>输出一个整数，表示答案对1000000007取模后的结果。</li></ul><ul><li>【样例输入1】<br>2 3<br>..X<br>.X.</li></ul><ul><li>【样例输出1】<br>4</li></ul><ul><li>【样例说明1】<br>成功的摆放有（其中O表示放置积木）：<br>(1)<br>..X<br>.X.<br>(2)<br>..X<br>OX.<br>(3)<br>O.X<br>OX.<br>(4)<br>..X<br>.XO</li></ul><ul><li>【样例输入2】<br>3 3<br>..X<br>.X.<br>…</li></ul><ul><li>【样例输出2】<br>16</li></ul><ul><li>【数据规模约定】<br>对于10%的数据，n=1，m&lt;=30；<br>对于40%的数据，n&lt;=10，m&lt;=30；<br>对于100%的数据，n&lt;=100，m&lt;=100。</li></ul><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 1000ms</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待补充....</span></span><br></pre></td></tr></table></figure><h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><h2 id="标题：矩阵求和"><a href="#标题：矩阵求和" class="headerlink" title="标题：矩阵求和"></a>标题：矩阵求和</h2><p>经过重重笔试面试的考验，小明成功进入 Macrohard 公司工作。<br>今天小明的任务是填满这么一张表：<br>表有 n 行 n 列，行和列的编号都从1算起。<br>其中第 i 行第 j 个元素的值是 gcd(i, j)的平方，<br>gcd 表示最大公约数，以下是这个表的前四行的前四列：<br>1  1  1  1<br>1  4  1  4<br>1  1  9  1<br>1  4  1 16</p><p>小明突然冒出一个奇怪的想法，他想知道这张表中所有元素的和。<br>由于表过于庞大，他希望借助计算机的力量。</p><ul><li>「输入格式」<br>一行一个正整数 n 意义见题。</li></ul><ul><li>「输出格式」<br>一行一个数，表示所有元素的和。由于答案比较大，请输出模 (10^9 + 7)(即：十亿零七) 后的结果。</li></ul><ul><li>「样例输入」<br>4</li></ul><ul><li>「样例输出」<br>48</li></ul><ul><li>「数据范围」<br>对于 30% 的数据，n &lt;= 1000<br>存在 10% 的数据，n = 10^5<br>对于 60% 的数据，n &lt;= 10^6<br>对于 100% 的数据，n &lt;= 10^7</li></ul><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 256M<br>CPU消耗  &lt; 2000ms<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待补充.....</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/06/01/2018蓝桥国赛b组题解/seimei.jpg" alt="不要让我看见你"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;h2 id=&quot;标题：换零钞&quot;&gt;&lt;a href=&quot;#标题：换零钞&quot; class=&quot;headerlink&quot; title=&quot;标题：换零钞&quot;&gt;&lt;/a&gt;标题：换零钞&lt;/h2&gt;&lt;p&gt;x星球的钞票的面额只有：100元，5元，2元，1元，共4种。&lt;br&gt;小明去x星旅游，他手里只有2张100元的x星币，太不方便，恰好路过x星银行就去换零钱。&lt;br&gt;小明有点强迫症，他坚持要求200元换出的零钞中2元的张数刚好是1元的张数的10倍，&lt;br&gt;剩下的当然都是5元面额的。&lt;/p&gt;
&lt;p&gt;银行的工作人员有点为难，你能帮助算出：在满足小明要求的前提下，最少要换给他多少张钞票吗？&lt;br&gt;（5元，2元，1元面额的必须都有，不能是0）&lt;/p&gt;
&lt;p&gt;注意，需要提交的是一个整数，不要填写任何多余的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://734432041.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="蓝桥" scheme="https://734432041.github.io/tags/%E8%93%9D%E6%A1%A5/"/>
    
      <category term="题解" scheme="https://734432041.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="C/C++" scheme="https://734432041.github.io/tags/C-C/"/>
    
      <category term="算法训练" scheme="https://734432041.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
</feed>
