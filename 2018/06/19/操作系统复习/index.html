<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|true:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="2018年春季学期计算机操作系统原理复习提纲（包括基本概念、管理原理、计算和综合应用）">
<meta name="keywords" content="复习,操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统复习">
<meta property="og:url" content="https://734432041.github.io/2018/06/19/操作系统复习/index.html">
<meta property="og:site_name" content="Code_dreamer">
<meta property="og:description" content="2018年春季学期计算机操作系统原理复习提纲（包括基本概念、管理原理、计算和综合应用）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/20170220154733687.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片1.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片2.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片3.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片4.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片5.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片6.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片7.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片8.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片9.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片10.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片11.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片12.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片13.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片14.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片15.jpg">
<meta property="og:image" content="https://734432041.github.io/2018/06/19/操作系统复习/图片16.jpg">
<meta property="og:updated_time" content="2018-07-02T10:30:30.429Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统复习">
<meta name="twitter:description" content="2018年春季学期计算机操作系统原理复习提纲（包括基本概念、管理原理、计算和综合应用）">
<meta name="twitter:image" content="https://734432041.github.io/2018/06/19/操作系统复习/20170220154733687.jpg">



  <link rel="alternate" href="/atom.xml" title="Code_dreamer" type="application/atom+xml" />




  <link rel="canonical" href="https://734432041.github.io/2018/06/19/操作系统复习/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>操作系统复习 | Code_dreamer</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://https://github.com/734432041" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code_dreamer</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Magician</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">
    <a href="/schedule/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />日程表</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">
    <a href="/404/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />公益 404</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://734432041.github.io/2018/06/19/操作系统复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiLinfeng">
      <meta itemprop="description" content="Be a dreamer,but not just a dreamer!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code_dreamer">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统复习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-19 17:39:23" itemprop="dateCreated datePublished" datetime="2018-06-19T17:39:23+08:00">2018-06-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-07-02 18:30:30" itemprop="dateModified" datetime="2018-07-02T18:30:30+08:00">2018-07-02</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/复习总结/" itemprop="url" rel="index"><span itemprop="name">复习总结</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="2018年春季学期计算机操作系统原理复习提纲"><a href="#2018年春季学期计算机操作系统原理复习提纲" class="headerlink" title="2018年春季学期计算机操作系统原理复习提纲"></a>2018年春季学期计算机操作系统原理复习提纲</h1><p>（包括基本概念、管理原理、计算和综合应用）</p>
<a id="more"></a>
<h2 id="Part-I操作系统概述"><a href="#Part-I操作系统概述" class="headerlink" title="Part I操作系统概述"></a>Part I操作系统概述</h2><h3 id="操作系统的资源管理技术"><a href="#操作系统的资源管理技术" class="headerlink" title="操作系统的资源管理技术"></a>操作系统的资源管理技术</h3><h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><ol>
<li><p>空分复用共享  </p>
<blockquote>
<p>将资源的不同单位同时分配给不同的进程。  </p>
<ul>
<li>内存可以存分若干个进程</li>
<li>外存（磁盘）同时为多个进程保存信息</li>
</ul>
</blockquote>
</li>
<li><p>时分复用共享  </p>
<blockquote>
<p>轮流的使用资源，每个进程获得资源后使用一小会，多个进程分时地共享这类资源</p>
<ul>
<li>独占<br>进程获得资源后使用一个完整的周期后才会释放（磁带机）</li>
<li>时分共享<br>进程获得资源后可能随时被剥夺，被另一个进程抢占（处理器）</li>
</ul>
</blockquote>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><pre><code>&gt; 解决物理资源数量不足，提高服务的能力和水平  
    &gt;&gt; 一个物理资源虚拟成多个逻辑上的对应物  
    &gt;&gt; 多个物理资源虚拟成单个逻辑上的对应物 
</code></pre><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><pre><code>&gt; 处理系统的复杂性，解决资源的易用性 
</code></pre><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><blockquote>
<p>管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好运行环境的一种系统软件</p>
</blockquote>
</li>
</ol>
<ul>
<li>服务用户观点————操作系统作为用户接口和公共服务程序</li>
<li>进程交互观点————操作系统作为进程执行的控制者和协调者</li>
<li>系统实现观点————操作系统作为扩展机或虚拟机</li>
<li>资源管理观点————操作系统作为资源的管理者和控制者<h3 id="操作系统的主要特性"><a href="#操作系统的主要特性" class="headerlink" title="操作系统的主要特性"></a>操作系统的主要特性</h3></li>
<li>并发性<br>两个或两个以上的活动或事件在同一时间间隔内发生 </li>
<li>异步性(随机性)<br>多道程序中允许多个程序并发执行，并发活动会导致随机事件的发生，由于资源有限而程序众多，每个程序的执行并不是连贯的</li>
<li>共享性<br>计算机系统中的资源可以被多个并发执行的程序共同使用，而不是被某个程序独占<h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3>（单道/多道批处理操作系统、分时操作系统、实时操作系统的基本特点）<h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4>根据预先设定的调度策略选择若干作业并发的执行，系统资源利用率高，作业吞吐量大。</li>
<li>批量集中处理</li>
<li>多道程序运行</li>
<li>作业脱机工作<h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4></li>
<li>同时性<br>若干终端用户联机使用计算机</li>
<li>独立性<br>终端用户彼此独立，互不干扰</li>
<li>即时性<br>请求在短时间内得到响应 </li>
<li>交互性<br>用户和机器交互，便于调试和排错 <h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><h3 id="操作系统提供给用户的几种接口"><a href="#操作系统提供给用户的几种接口" class="headerlink" title="操作系统提供给用户的几种接口"></a>操作系统提供给用户的几种接口</h3></li>
</ul>
<ol>
<li>程序接口<br>操作系统对外提供服务和功能的手段，由系统调用组成。 </li>
<li>操作接口<br>由一组控制命令或作业控制语言组成，是操作系统为用户提供的组织和控制其作业（应用程序）执行的手段 <h3 id="什么是系统调用-API、库函数和系统调用之间的区别和联系"><a href="#什么是系统调用-API、库函数和系统调用之间的区别和联系" class="headerlink" title="什么是系统调用? API、库函数和系统调用之间的区别和联系"></a>什么是系统调用? API、库函数和系统调用之间的区别和联系</h3></li>
</ol>
<ul>
<li>系统调用<blockquote>
<p>系统调用，指运行在用户空间的应用程序向操作系统内核请求某些服务的调用过程。<br>是<code>应用程序</code>同<code>系统</code>之间的接口。</p>
</blockquote>
</li>
<li>库函数<blockquote>
<p>库函数，是由用户或组织自己开发的，具有一定功能的函数集合。 </p>
</blockquote>
</li>
<li>API<blockquote>
<p>API（应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。  </p>
</blockquote>
<h4 id="系统调用与函数调用之间的区别"><a href="#系统调用与函数调用之间的区别" class="headerlink" title="系统调用与函数调用之间的区别"></a>系统调用与函数调用之间的区别</h4></li>
</ul>
<ol>
<li>调用的形式和实现方式不同</li>
<li>被调用代码的位置不同</li>
<li>提供方式不同<h3 id="什么是原语？用户应用程序如何调用原语功能？举例Linux原语"><a href="#什么是原语？用户应用程序如何调用原语功能？举例Linux原语" class="headerlink" title="什么是原语？用户应用程序如何调用原语功能？举例Linux原语"></a>什么是原语？用户应用程序如何调用原语功能？举例Linux原语</h3><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4>原语是由若干机器指令构成，用于完成某种特定的系统功能的一段程序，具有<code>不可分割性</code>，即原语的执行必须是连续的，不可被打断的。<h4 id="举例Linux原语"><a href="#举例Linux原语" class="headerlink" title="举例Linux原语"></a>举例Linux原语</h4></li>
<li>进程控制原语：fork()</li>
<li>系统调用：exec函数族</li>
<li>系统调用终止进程：exit()</li>
<li>系统调用等待子程序暂停或中止：wait()</li>
</ol>
<h3 id="第一章课后计算题"><a href="#第一章课后计算题" class="headerlink" title="第一章课后计算题"></a>第一章课后计算题</h3><h2 id="Part-II处理器管理"><a href="#Part-II处理器管理" class="headerlink" title="Part II处理器管理"></a>Part II处理器管理</h2><h3 id="CPU的两种工作状态"><a href="#CPU的两种工作状态" class="headerlink" title="CPU的两种工作状态"></a>CPU的两种工作状态</h3><h4 id="内核态（系统态、管理态、管态）"><a href="#内核态（系统态、管理态、管态）" class="headerlink" title="内核态（系统态、管理态、管态）"></a>内核态（系统态、管理态、管态）</h4><pre><code>操作系统管理管理程序运行时所处的状态，处理器正在运行可信系统软件，此时全部机器指令都被允许在处理机上执行，程序可访问所有内存单元和系统资源，且具有改变处理器状态的能力
</code></pre><h4 id="用户态（目态）"><a href="#用户态（目态）" class="headerlink" title="用户态（目态）"></a>用户态（目态）</h4><pre><code>正在运行非可信应用程序，此时无法执行特权指令，且访问仅限于当前处理器上执行程序所在的地址空间，防止操作系统受到应用程序的侵害
</code></pre><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断    不被阻塞<br>异常    可以阻塞</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是指程序执行过程中遇到急需处理的事件时，中止现行程序在CPU上的运行，转而处理相应的事件处理程序，待事件处理完成后再返回断点继续执行的过程。</p>
<h5 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h5><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可将中断划分为<code>外中断</code>和<code>内中段</code></p>
<h6 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h6><p>外中断又称中断或异步中断，是指来自处理器之外的中断信号（时钟中断、键盘中断、外部设备中断）。外中断又分为<code>可屏蔽中断</code>和<code>不可屏蔽中断</code>。在处理级别较高的中断时，往往会部分或全部屏蔽低级中断。</p>
<h6 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h6><p>内中断又称异常或同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。内中断可细分为：  </p>
<ol>
<li>访管中断，由执行系统调用引起</li>
<li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li>
<li>程序性中断，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点溢出等<h4 id="中断响应需要执行的四件事"><a href="#中断响应需要执行的四件事" class="headerlink" title="中断响应需要执行的四件事"></a>中断响应需要执行的四件事</h4></li>
<li>发现中断源</li>
<li>保护现场</li>
<li>执行中断\异常处理程序</li>
<li>恢复现场<h3 id="进程与程序、进程与线程之间的区别联系"><a href="#进程与程序、进程与线程之间的区别联系" class="headerlink" title="进程与程序、进程与线程之间的区别联系"></a>进程与程序、进程与线程之间的区别联系</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><code>进程</code>是操作系统中最<code>最基本</code>、<code>最重要</code>的概念，指一个程序的一次执行过程。<h5 id="进程的目的"><a href="#进程的目的" class="headerlink" title="进程的目的"></a>进程的目的</h5></li>
<li>刻画进程的并发性</li>
<li>解决资源的共享性<h5 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h5></li>
<li>动态性，是程序的一次执行过程，有生命周期，是动态的概念</li>
<li>共享性，多个不同的进程可执行相同的程序</li>
<li>独立性，每个进程都是一个独立的实体，有自己的虚存空间、程序计数器、内部状态</li>
<li>制约性，多个进程因为共享资源或协同工作产生相互的制约关系</li>
<li>并发性，多个进程在时间上可以重叠，可以并发。</li>
</ol>
<h5 id="进程和程序的区别和联系"><a href="#进程和程序的区别和联系" class="headerlink" title="进程和程序的区别和联系"></a>进程和程序的区别和联系</h5><ol>
<li>区别<ul>
<li>进程是动态的，程序是静态的</li>
<li>进程有一定的生命周期，而程序是一组指令的集合</li>
<li>一个程序可以对应多个进程，一个进程只能对应一个程序</li>
</ul>
</li>
<li>联系<ul>
<li>程序不能单独执行，只能加载到内存中，系统分配资源后执行，这种执行的程序就叫做进程<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5>线程是进程的一个实体,也是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程<br>线程自己基本上不拥有系统资源，也没有自己的地址空间，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化</li>
</ul>
</li>
</ol>
<h5 id="进程和线程的区别和联系"><a href="#进程和线程的区别和联系" class="headerlink" title="进程和线程的区别和联系"></a>进程和线程的区别和联系</h5><ol>
<li>区别  </li>
</ol>
<ul>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</li>
<li>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</li>
<li>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</li>
<li>系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。</li>
</ul>
<ol start="2">
<li>联系</li>
</ol>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
<li>处理机分给线程，即真正在处理机上运行的是线程。</li>
<li>线程是指进程内的一个执行单元，也是进程内的可调度实体。</li>
</ul>
<h3 id="父进程与子进程之间的关系"><a href="#父进程与子进程之间的关系" class="headerlink" title="父进程与子进程之间的关系"></a>父进程与子进程之间的关系</h3><p>子进程的代码段和父进程共享，子进程的其他资源是父进程的一个副本，也就是说，在创建子进程后，子进程和父进程就是两个独立的进程。</p>
<h3 id="进程的3态模型、进程的5态模型、引发各种状态转换的原因"><a href="#进程的3态模型、进程的5态模型、引发各种状态转换的原因" class="headerlink" title="进程的3态模型、进程的5态模型、引发各种状态转换的原因"></a>进程的3态模型、进程的5态模型、引发各种状态转换的原因</h3><p><a href="https://blog.csdn.net/qwe6112071/article/details/70473905" target="_blank" rel="noopener">https://blog.csdn.net/qwe6112071/article/details/70473905</a></p>
<h3 id="操作系统的三级调度"><a href="#操作系统的三级调度" class="headerlink" title="操作系统的三级调度"></a>操作系统的三级调度</h3><h4 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h4><p>又称作业调度，长程调度，主要功能是按照作业调度策略，从后备作业调度队列挑选若干作业进入内存，分配资源并创建进程</p>
<h4 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h4><p>又称平衡调度，中程调度，主要功能是根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中进程的对换工作。从等待队列中挑选作业到挂起等待队列，从挂起等待队列挑选作业到挂起就绪队列</p>
<h4 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h4><p>又称进程调度/线程调度，短程调度。功能是根据某种原则，决定就绪队列中的哪个进程获得CPU，并将CPU给它用</p>
<p><img src="/2018/06/19/操作系统复习/20170220154733687.jpg" alt="处理器三级调度模型"></p>
<h3 id="常用的作业调度算法、进程调度算法"><a href="#常用的作业调度算法、进程调度算法" class="headerlink" title="常用的作业调度算法、进程调度算法"></a>常用的作业调度算法、进程调度算法</h3><ol>
<li>先来先服务算法(FCFS),按照作业进入系统后备队列的先后次序来挑选作业。（同样适用于进程/线程调度算法，每次从就绪队列中选择最先进入的进程/队列，它会一直运行到完成或者被阻塞让出处理器为止）(非剥夺算法)</li>
<li>最短作业优先算法(SJF),以进入系统作业所要求的CPU运行时间长短为标准，选取预计计算事件最短的作业。(非剥夺算法)</li>
<li>最短剩余时间优先算法(SRTF),当某进程/某线程进入就绪队列，若它所需要的CPU运行时间比当前运行进程/线程时间短，抢占式最短作业优先算法强行剥夺当前执行者的控制权，调度新进程/线程执行(剥夺算法)</li>
<li>最高响应比优先算法(HRRF)<blockquote>
<p>响应比 = 作业周转时间/作业处理时间</p>
<pre><code>=(作业等待时间+作业处理时间)/作业处理时间
=1+作业等待时间/作业处理时间
</code></pre><p> 按响应比从大到小顺序执行<br> 当响应比算法用于进程调度时<br>响应比 = 1+进程等待时间/进程估计计算时间<br> (非剥夺算法)</p>
</blockquote>
</li>
<li>优先级算法，根据确定的优先级选取进程/线程，总是选择就绪队列中优先级最高者投入运行。</li>
<li>轮转调度算法(时间片调度算法)，调度程序每次把CPU分配给就绪队列首进程/线程使用规定的时间间隔，成为时间片(10-200ms)，就绪队列中的每个进程/线程轮流的运行一个时间片，一个时间片耗尽时，强制让出CPU<h3 id="第二章课后作业调度、进程调度有关的计算题"><a href="#第二章课后作业调度、进程调度有关的计算题" class="headerlink" title="第二章课后作业调度、进程调度有关的计算题"></a>第二章课后作业调度、进程调度有关的计算题</h3></li>
</ol>
<h2 id="PartIII同步、通信与死锁"><a href="#PartIII同步、通信与死锁" class="headerlink" title="PartIII同步、通信与死锁"></a>PartIII同步、通信与死锁</h2><h3 id="进程并发的概念；互斥、同步的概念"><a href="#进程并发的概念；互斥、同步的概念" class="headerlink" title="进程并发的概念；互斥、同步的概念"></a>进程并发的概念；互斥、同步的概念</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>一组进程的执行在时间上是重叠的，就称他们是并发执行的<br>并发的实质是一个处理器在几个进程之间的<code>多路复用</code>，并发是对有限的物理资源强制行使多用户共享，消除计算机部件之间的互等现象，以提高系统资源利用率。</p>
<h4 id="并发执行进程的目的"><a href="#并发执行进程的目的" class="headerlink" title="并发执行进程的目的"></a>并发执行进程的目的</h4><ul>
<li>充分发挥硬件的并行性，提高系统效率</li>
<li>并发程序设计是多道程序设计的基础<h4 id="进程互斥的概念"><a href="#进程互斥的概念" class="headerlink" title="进程互斥的概念"></a>进程互斥的概念</h4><code>进程互斥</code>是指若干个进程因相互争夺独占型资源时所产生的<code>竞争制约</code>关系<h4 id="进程同步的概念"><a href="#进程同步的概念" class="headerlink" title="进程同步的概念"></a>进程同步的概念</h4><code>进程同步</code>指为完成共同任务的并发进程基于某个条件来<code>协调</code>它们的活动，因为需要在某些位置上排定<strong>执行的先后次序而等待</strong>、<strong>传递信号或消息</strong>所产生的<code>协作制约</code>关系  <h4 id="同步和互斥的关系"><a href="#同步和互斥的关系" class="headerlink" title="同步和互斥的关系"></a>同步和互斥的关系</h4></li>
</ul>
<ol>
<li><code>互斥</code>是不能同时使用</li>
<li><code>同步</code>是不但不能同时使用，而且由使用的先后顺序</li>
<li>互斥关系是一种<strong>特殊</strong>的进程同步关系，即逐次使用互斥共享资源，是对进程使用资源次序上的一种协调。</li>
</ol>
<p><code>并发进程共享临界资源，分析如果不加控制，可能会出现的不确定的结果</code></p>
<h4 id="互斥管理准则"><a href="#互斥管理准则" class="headerlink" title="互斥管理准则"></a>互斥管理准则</h4><ul>
<li><code>空闲让进</code>：当没有进程在临界区时，任何需要进入临界区的进程都允许立即进入。 </li>
<li><code>忙则等待</code>：在共享同一对象的所有进程中，一次只能有一个进程进入临界区。其它要求进入临界区的进程只能等待。 </li>
<li><code>有限等待</code>：任何一个进程经有限时间等待后都能进入临界区，不允许出现进程死锁或饥饿的情况发生。 </li>
<li><code>让权等待</code>：当一个进程不能进入临界区时要立即阻塞自己，释放处理机让其它进程使用，避免“忙等”。 </li>
</ul>
<h3 id="分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）"><a href="#分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）" class="headerlink" title="分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）"></a>分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）</h3><h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>	             </span></span><br><span class="line"><span class="function">Begin	                     </span></span><br><span class="line">……		                     </span><br><span class="line"> While (turn≠<span class="number">1</span>) <span class="keyword">do</span> skip;        </span><br><span class="line">  Critical section;		          </span><br><span class="line">    turn = <span class="number">2</span>;		                </span><br><span class="line">……	                         </span><br><span class="line">end.	                     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">While (turn≠<span class="number">2</span>) <span class="keyword">do</span> skip;</span><br><span class="line"> Critical section;</span><br><span class="line">  turn = <span class="number">1</span>;</span><br><span class="line">……</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>
<p>分析：主要出现了两个问题。  </p>
<ol>
<li>用0和1代表两个进程，它们只能按照01010101的顺序访问临界区，大大降低了操作系统的效率</li>
<li>如果出现一个进程因为错误而退出，没有修改turn值，那么另一个进程就用于不能得到进入临界区的机会<br>主要违反了<code>空闲让进</code>，<code>有限等待</code>原则。 <h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>	            </span></span><br><span class="line"><span class="function">Begin	                                </span></span><br><span class="line">……		                         </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> skip;  </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;		      </span><br><span class="line">Critical section;	               </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;		       </span><br><span class="line">……	                             </span><br><span class="line">end.	                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> skip;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分析：主要问题是，当一个进程通过了<code>while</code>循环，而还没有修改Flag变量，此时系统切换到另一个进程执行时，也能够通过<code>while</code>循环，照成了两个进程同时进入临界区<br>主要违反了<code>忙则等待</code>原则</p>
<h4 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>	            </span></span><br><span class="line"><span class="function">Begin	                      </span></span><br><span class="line">……	                        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;		      </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> skip;    </span><br><span class="line">Critical section;		        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;		      </span><br><span class="line">……		                 </span><br><span class="line">end.	                        </span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> skip;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>分析：主要问题是，当第一个进程修改了Flag值，还没由通过<code>while</code>循环，此时系统切换到另一个进程执行时，也修改了了Flag值，那么两个进程都无法通过<code>while</code>循环。照成了死锁。<br>主要违反了<code>空闲让进</code>原则</p>
<h4 id="第四次尝试"><a href="#第四次尝试" class="headerlink" title="第四次尝试"></a>第四次尝试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>	                            </span></span><br><span class="line"><span class="function">Begin	                                        </span></span><br><span class="line">……		                               </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;		                  </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> 		      </span><br><span class="line">&#123;flag[<span class="number">1</span>]=<span class="literal">false</span>; 	                   </span><br><span class="line">  flag[<span class="number">1</span>]=<span class="literal">true</span>&#125;;	                   </span><br><span class="line">Critical section;		       	</span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;		       </span><br><span class="line">……		                                     </span><br><span class="line">end.	                                           </span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">……</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span> </span><br><span class="line">&#123;flag[<span class="number">2</span>]=<span class="literal">false</span>;</span><br><span class="line">    flag[<span class="number">2</span>]=<span class="literal">true</span>&#125;;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>分析：主要的问题是，可能出现两个进程并发度极高，同时修改Flag值，又同时进入<code>while</code>循环，同时释放Flag值，导致了两个进程都不能时用共享区<br>违反了<code>空闲让进</code>原则</p>
<h4 id="“正确”的算法"><a href="#“正确”的算法" class="headerlink" title="“正确”的算法"></a>“正确”的算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">1</span>)</span>	                  </span></span><br><span class="line"><span class="function">Begin	                  </span></span><br><span class="line">……		        </span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">true</span>;		     </span><br><span class="line">While (Flag[<span class="number">2</span>]) <span class="keyword">do</span> 		      </span><br><span class="line"><span class="keyword">if</span> (turn=<span class="number">2</span>) 		     </span><br><span class="line">&#123;flag[<span class="number">1</span>]=<span class="literal">false</span>;			 </span><br><span class="line"> <span class="keyword">while</span> (turn=<span class="number">2</span>) <span class="keyword">do</span> skip;			 </span><br><span class="line"> flag[<span class="number">1</span>]=<span class="literal">true</span>&#125;;			 </span><br><span class="line">Critical section;	                   </span><br><span class="line">turn=<span class="number">2</span>;		      turn=<span class="number">1</span>;</span><br><span class="line">Flag[<span class="number">1</span>] = <span class="literal">false</span>;		      </span><br><span class="line">……		         ……</span><br><span class="line">end.	                    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Process <span class="title">P</span> <span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">begin</span></span><br><span class="line">Flag[2] = true;</span><br><span class="line">While (Flag[<span class="number">1</span>]) <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> (turn=<span class="number">1</span>)</span><br><span class="line">&#123;flag[<span class="number">2</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (turn=<span class="number">1</span>) <span class="keyword">do</span> skip;</span><br><span class="line">    flag[<span class="number">2</span>]=<span class="literal">true</span>&#125;;</span><br><span class="line">Critical section;</span><br><span class="line">Flag[<span class="number">2</span>] = <span class="literal">false</span>;</span><br><span class="line">end.</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>分析：基本解决了用软件方式实现互斥算法，但是，在<code>while</code>里执行的时无用的代码段，还是降低了系统的效率。<br>此外，使用Dekker算法只能解决两个进程的互斥问题，在面对多进程互斥时算法的编写时非常复杂的</p>
<h3 id="应用信号量机制（PV操作）解决进程同步互斥问题"><a href="#应用信号量机制（PV操作）解决进程同步互斥问题" class="headerlink" title="应用信号量机制（PV操作）解决进程同步互斥问题"></a>应用信号量机制（PV操作）解决进程同步互斥问题</h3><h4 id="信号量机制原理"><a href="#信号量机制原理" class="headerlink" title="信号量机制原理"></a>信号量机制原理</h4><p>为每个临界资源设置一个信号量，负责在多个进程之间转发互斥信息。当一个进程需要互斥使用某个临界资源时，可通过对信号量的P操作，了解该资源的空闲情况。当它使用完该临界资源后，又可通过对相关信号量的V操作，让其它需要该资源的进程感知到它的离去。</p>
<h4 id="p原语的功能"><a href="#p原语的功能" class="headerlink" title="p原语的功能"></a>p原语的功能</h4><pre><code>P原语具有“阻塞”功能，当某个临界资源被其他进程占用时，就将自己阻塞；
</code></pre><h4 id="V原语的功能"><a href="#V原语的功能" class="headerlink" title="V原语的功能"></a>V原语的功能</h4><pre><code>V原语具有“唤醒”功能，它能将等待该资源的进程唤醒。
</code></pre><p>（课件例题、练习题、作业题）<br>   生产者-消费者类型、读者-写者类型、理发师类型、<br>   哲学家就餐类型、进程DAG图类型</p>
<h3 id="父子进程之间进行通信的几种方式（结合实验课程）"><a href="#父子进程之间进行通信的几种方式（结合实验课程）" class="headerlink" title="父子进程之间进行通信的几种方式（结合实验课程）"></a>父子进程之间进行通信的几种方式（结合实验课程）</h3><h4 id="信号通信"><a href="#信号通信" class="headerlink" title="信号通信"></a>信号通信</h4><h5 id="软中断的概念"><a href="#软中断的概念" class="headerlink" title="软中断的概念"></a>软中断的概念</h5><p>不必由硬件产生中断源而引起的中断称为软中断，软中断是利用硬中断的概念，采用软件方法对中断机制进行模拟，实现宏观上的异步执行。<br>信号是一种软中断机制，信号的发送者相当于中断源（或是内核，或是进程），而信号的接收者必然是一个进程（相当于CPU）</p>
<h5 id="软中断的用法"><a href="#软中断的用法" class="headerlink" title="软中断的用法"></a>软中断的用法</h5><p>用于内核或进程对某个进程发出中断，向进程通知某个特定事件发生或迫使进程执行信号处理程序</p>
<h5 id="中断机制和信号机制的比较"><a href="#中断机制和信号机制的比较" class="headerlink" title="中断机制和信号机制的比较"></a>中断机制和信号机制的比较</h5><p>相同点：</p>
<ol>
<li>两者在概念上是一致的，进程接收到信号和CPU接收中断是相似的。</li>
<li>两者都是异步的，CPU和进程在工作过程中都不知道中断和信号何时产生，不需要停下来等到信号的发生。</li>
<li>两者在在实现上都采用向量表，中断机制设置中断向量表，信号机制设置信号向量表。</li>
<li>两者均有屏蔽设施，中断机制可以对中断源屏蔽，信号机制可以设置信号屏蔽位，对发来的信号不予理睬。<br>区别:</li>
<li>中断机制由软件加硬件实现，信号机制完全由软件实现</li>
<li>中断向量表和中断处理程序位于系统空间，信号向量表位于系统空间，而信号处理程序由程序提供。<h4 id="管道通讯"><a href="#管道通讯" class="headerlink" title="管道通讯"></a>管道通讯</h4>管道是连接读写程序的一个特殊文件，允许按照FIFO方式传送数据，使进程同步执行。<br>管道是单向的<br>发送进程视管道为输出文件，以字符流的形式把数据送入管道。<br>接收进程视管道为输入文件，从管道中接收文件。</li>
</ol>
<h4 id="共享内存通讯"><a href="#共享内存通讯" class="headerlink" title="共享内存通讯"></a>共享内存通讯</h4><p>共享内存是指两个或多个进程共同拥有一块内存区，该区中的进程可被进程访问。</p>
<h4 id="消息队列通讯"><a href="#消息队列通讯" class="headerlink" title="消息队列通讯"></a>消息队列通讯</h4><h3 id="死锁的基本概念、死锁产生的原因、4个必要条件"><a href="#死锁的基本概念、死锁产生的原因、4个必要条件" class="headerlink" title="死锁的基本概念、死锁产生的原因、4个必要条件"></a>死锁的基本概念、死锁产生的原因、4个必要条件</h3><h4 id="死锁的基本概念"><a href="#死锁的基本概念" class="headerlink" title="死锁的基本概念"></a>死锁的基本概念</h4><p>如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁</p>
<h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ol>
<li>资源的可用量小于需求量</li>
<li>动态资源分配策略</li>
<li>偶然性</li>
</ol>
<h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ol>
<li>互斥条件：临界资源是独占资源，进程应该互斥且排他的使用这些资源</li>
<li>占有和等待条件：进程在请求资源得不到满足而等待时，不释放已拥有的资源</li>
<li>不剥夺条件：进程获得的资源只能由进程自愿释放，不允许被其他进程剥夺</li>
<li>循环等待条件（环路条件）：循环等待链，每个进程都在等待链中等待下一个进程所持有的资源，造成永久等待状态</li>
</ol>
<h3 id="死锁预防、死锁避免、死锁检测的概念"><a href="#死锁预防、死锁避免、死锁检测的概念" class="headerlink" title="死锁预防、死锁避免、死锁检测的概念"></a>死锁预防、死锁避免、死锁检测的概念</h3><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>死锁的预防主要是破坏死锁产生的四个必要条件。</p>
<ul>
<li>破坏条件一：进程可以同时使用资源，但是有很多资源（如可写文件、键盘、磁带机等）是不能够被同时使用的</li>
<li>破坏条件二：主要采用静态分配策略，即在进程执行前就分配给它所需要的资源，主要问题是，资源利用率和进程并发度降低。</li>
<li>破坏条件三：剥夺调度能够有效的预防死锁，但是只适用于内存和处理器资源。</li>
<li>破坏条件四：采用按层次分配策略，将系统的所有资源排列到不同的层次中，一个进程得到某层次的资源后，才能申请更高一层的资源，同样，一个进程在释放某一层次资源前，要释放所有更高层次的资源。</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>采用银行家算法（动态资源分配策略），允许操作系统中同时存在前三个必要条件，通过合适的资源分配算法，确保不会出现进程循环等待链。</p>
<h5 id="银行家算法的数据结构"><a href="#银行家算法的数据结构" class="headerlink" title="银行家算法的数据结构"></a>银行家算法的数据结构</h5><ol>
<li>每类资源总数向量<code>Resource = [R1,R2,R3,...,Rm]</code></li>
<li>每类资源当前可用量<code>Available = [V1,V2,V3,...,Vm]</code></li>
<li>每个进程对各类资源的最大需求矩阵<code>Claim[i,j] = k</code>,表示<code>进程pi</code>对<code>资源Rj</code>的最大需求量为<code>k</code>个</li>
<li>每个进程已经拥有的各类资源矩阵<code>Allocation[i,j] = k</code>，表示<code>进程pi</code>已经拥有<code>资源Rj</code>的数量为<code>k</code>个</li>
<li>每个进程对各类资源的尚需矩阵<code>Need[i,j] = k</code>,表示<code>进程Pi</code>对<code>资源Rj</code>还需要<code>k</code>个，<code>Need[i,j] = Claim[i,j] - Allocation[i,j]</code></li>
<li>每个进程当前申请各类资源的数量矩阵<code>Request[i,j] = k</code>,表示<code>进程Pi</code>当前申请<code>资源Rj</code>的数目为<code>k</code>个<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><h5 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h5>死锁检测程序  </li>
<li>如果进程 - 资源分配图中<strong>无环路</strong>，此时系统没有发生死锁</li>
<li>如果进程 - 资源分配图中<strong>有环路</strong>，且每个资源类中<strong>仅有一个资源</strong>，则系统中发生死锁。此时，环路是系统发生死锁的<strong>充分必要条件</strong>，环路中的进程就是死锁进程。</li>
<li>如果进程 - 资源分配图中<strong>有环路</strong>，且所涉及的资源类中有<strong>多个资源</strong>，则环路的产生只是死锁产生的<strong>必要条件而不是充分条件</strong>,系统未必会发生死锁</li>
</ol>
<h5 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h5><p>系统处于死锁状态的充分必要条件是：当且仅当此状态的进程 - 资源分配图是不可完全简化的，这一充分条件称为死锁定理。</p>
<h3 id="第三章课后应用题和计算题"><a href="#第三章课后应用题和计算题" class="headerlink" title="第三章课后应用题和计算题"></a>第三章课后应用题和计算题</h3><h2 id="PartIV存储管理"><a href="#PartIV存储管理" class="headerlink" title="PartIV存储管理"></a>PartIV存储管理</h2><h3 id="静态地址重定位和动态地址重定位"><a href="#静态地址重定位和动态地址重定位" class="headerlink" title="静态地址重定位和动态地址重定位"></a>静态地址重定位和动态地址重定位</h3><ul>
<li>物理地址：绝对地址</li>
<li>逻辑地址：相对地址</li>
<li>重定位：逻辑地址 –&gt; 物理地址<h4 id="静态地址重定位"><a href="#静态地址重定位" class="headerlink" title="静态地址重定位"></a>静态地址重定位</h4></li>
<li>地址转换工作在进程执行前一次完成；</li>
<li>无须硬件支持，易于实现，但不允许程序在执行过程中移动位置。</li>
</ul>
<h4 id="动态地址重定位"><a href="#动态地址重定位" class="headerlink" title="动态地址重定位"></a>动态地址重定位</h4><ul>
<li>地址转换推迟到最后的可能时刻，即进程执行时才完成；</li>
<li>允许程序在主存中移动、便于主存共享、主存利用率高。</li>
</ul>
<h3 id="动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）"><a href="#动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）" class="headerlink" title="动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）"></a>动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）</h3><h4 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h4><p>又称为<strong>静态分区模式</strong>，内存空间被划分为数目固定的分区，各分区的大小不等，每个分区至装入一个作业，若多个分区都装有作业，它们可以并发执行。</p>
<h4 id="可变分区"><a href="#可变分区" class="headerlink" title="可变分区"></a>可变分区</h4><p>又称为<strong>动态分区模式</strong>，按照作业大小划分分区，但是划分的时间，大小，位置都是动态的。</p>
<h5 id="内碎片"><a href="#内碎片" class="headerlink" title="内碎片"></a>内碎片</h5><p>指的是作业获得的空间大于需求的空间时多出来的一小部分用户根本不需要的空闲区。</p>
<h5 id="外碎片"><a href="#外碎片" class="headerlink" title="外碎片"></a>外碎片</h5><p>指的是在使用可变分区管理方法时，进程之间形成的一些零零星星的小空闲区。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>数据结构由两张表组成，<code>已分配分区表</code>，<code>未分配分区表</code>，当装入新作业时，从未分配分区表中找出一个足够容纳它的空闲区，将此区分为两部分，一部分用来装入新作业，成为已分配区，另一部分仍是空闲区，将非空闲区的部分登记在已分配分区表（起始地址，占用长度），修改未分配分区该空闲区的起始地址和占用长度。由于分区的数目不定，两个表都可以使用链表实现。</p>
<ol>
<li>内存分配表（MAT表）</li>
</ol>
<ul>
<li>分区号：每个分区都有一个编号，用以区别不同分区。</li>
<li>起始地址：分区的起始地址，即首地址。</li>
<li>长度：分区的总长，一般以KB为单位。</li>
<li>占用标志：记录分区的使用状态。若占用标志为0，表明该分区为空闲，可以进行分配。若为非0（比如，填的是一个进程名称），意味着该分区已分配给进程使用。</li>
</ul>
<ol start="2">
<li><p>空闲区表/链<br>空闲区表是记录内存空闲区状况的数据结构。将当前空闲区单独组成一个链表是一种好方法。空闲区链中每一个结点代表一个空闲区。其中包括：分区号、起始地址、长度、链接指针等。</p>
</li>
<li><p>位示图<br>位示图是存储器的一种存储空间映像，系统可以根据位图来进行存储空间的管理。对每个位用0或1表示是否分配</p>
</li>
</ol>
<h4 id="主存分配算法"><a href="#主存分配算法" class="headerlink" title="主存分配算法"></a>主存分配算法</h4><ol>
<li>最先适应（first fit）：在未分配区找到的第一个长度满足要求的空闲区就分配。有利于高地址保持一个较大的空闲区用于大作业的装入，但是内存高低地址使用不平均，对回收算法也带来麻烦。</li>
<li>下次适应（next fit）（循环最先适应(Circlu first fit)）：从未分配区上次扫描结束处顺序查找未分配区，找到第一个长度满足要求的空闲区就分配。是first fit的变化，能够缩短查找时间，使内存的利用率更加均衡。</li>
<li>最优适应（best fit）：扫描整个未分配表，从空闲区中挑选一个能够满足用户进程要求的最小空闲区。保证不会分割大的空闲区，内存利用率高，缺点是，如果空闲区比所需要的长度略长，分割后会使得剩下的空闲区很小，形成了很多外碎片，不能利用，此外，每次都要对内存的每个未分配区查找一次，时间开销很大。</li>
<li>最坏适应（worst fit）：扫描整个未分配表，找出满足要求的最长的空闲区分配。这样，每次剩下的空闲区不会太小，减少了外碎片的产生。但是没有解决时间开销的问题。而且，每次将大的空闲区分成小块，对中小作业比较友好，不利于大作业的分配。</li>
</ol>
<h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p>当操作系统要回收一个已经分配的空闲块时</p>
<ol>
<li>在未分配表中按照<code>空闲块的大小</code>或<code>地址</code>找到一个合适的位置</li>
<li>插入一个结点，包括空闲块的起始地址，长度，占用标识，下个块的地址</li>
<li>如果该空闲块的前后有空闲块，可以合并</li>
</ol>
<h4 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h4><p> 固定分区存储管理<br><img src="/2018/06/19/操作系统复习/图片1.jpg" alt="固定分区存储管理地址转换和存储保护"></p>
<p> 动态分区存储管理<br><img src="/2018/06/19/操作系统复习/图片2.jpg" alt="可变分区地址转换与存储保护"></p>
<h3 id="内存不足的存储管理技术"><a href="#内存不足的存储管理技术" class="headerlink" title="内存不足的存储管理技术"></a>内存不足的存储管理技术</h3><h4 id="移动技术-程序浮动"><a href="#移动技术-程序浮动" class="headerlink" title="移动技术(程序浮动)"></a>移动技术(程序浮动)</h4><p><img src="/2018/06/19/操作系统复习/图片3.jpg" alt="移动技术"></p>
<h5 id="程序浮动的要求"><a href="#程序浮动的要求" class="headerlink" title="程序浮动的要求"></a>程序浮动的要求</h5><ol>
<li>程序不能正在运行</li>
<li>采用动态内存分配</li>
<li>不能为堵塞等待IO的进程</li>
</ol>
<h4 id="对换技术（主存扩充）"><a href="#对换技术（主存扩充）" class="headerlink" title="对换技术（主存扩充）"></a>对换技术（主存扩充）</h4><ul>
<li>实存储器（实存）：内存</li>
<li>虚存储器（虚存）：磁盘SWAP区（虚拟成内存使用）</li>
</ul>
<h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p>当一个或多个驻留进程处于堵塞态时，选择其中一个进程，暂时移出内存，让其他进程使用内存，把磁盘中的某个进程换入内存。</p>
<ul>
<li>交换整个作业————用于单道系统</li>
<li>交换整个进程————连续存储管理</li>
<li>交换页面/段面————虚拟存储管理</li>
</ul>
<h5 id="磁盘文件区和交换区的不同"><a href="#磁盘文件区和交换区的不同" class="headerlink" title="磁盘文件区和交换区的不同"></a>磁盘文件区和交换区的不同</h5><ul>
<li><p>存储方式的不同<br>文件区中的信息是以文件形式存放的，为了提高空间利用率，一般采取<code>离散存储</code>方式<br>交换区中的信息是按字符流方式存放，多采用<code>连续存储</code>形式。</p>
</li>
<li><p>访问速度的不同<br>文件区的存储空间特别大，为了提高检索效率一般通过建立目录对文件实现访问，也就是<code>间接地址访问</code><br>交换区空间较小，可按外存地址<code>直接访问</code>，因此速度快</p>
</li>
<li><p>存取时间的不同<br>文件区的存储适合于<code>较长久</code>的数据存储<br>交换区作为临时数据的存放处，只存放<code>短期</code>的数据。 </p>
</li>
</ul>
<h4 id="覆盖技术（主存扩充）"><a href="#覆盖技术（主存扩充）" class="headerlink" title="覆盖技术（主存扩充）"></a>覆盖技术（主存扩充）</h4><p>覆盖技术，是程序运行过程中，在不同时刻把同一存储区分配给不同程序段或数据段，<code>实现存储区共享</code>的一种内存分配技术。<br>覆盖技术通常与<code>单一连续区分配</code>、<code>固定分区分配</code>和<code>动态分区分配</code>等存储管理技术配合使用。<br>每一个用户程序都被分为若干程序段，一部分是经常要用的基本部分，作为常驻程序（<code>非覆盖段</code>）；另一部分不经常使用，可以让它们在需要时临时装入（<code>可覆盖段</code>）。当一段在内存中的程序运行完毕（或者暂时不运行）时，可以令它们放弃驻留权，让另一段程序占用它在内存中的位置。</p>
<h3 id="分页式存储管理的管理机制（基本分页、请求分页）"><a href="#分页式存储管理的管理机制（基本分页、请求分页）" class="headerlink" title="分页式存储管理的管理机制（基本分页、请求分页）"></a>分页式存储管理的管理机制（基本分页、请求分页）</h3><h4 id="分页存储管理的基本原理"><a href="#分页存储管理的基本原理" class="headerlink" title="分页存储管理的基本原理"></a>分页存储管理的基本原理</h4><p>将内存空间划分为大小固定相等的块（Frame帧、页框、主存块），且每一块空间较小<br>将每个进程划分为同样大小的块(page页)<br>进程中称为页的块指定到内存中称为帧的块(一页对应一帧)</p>
<h5 id="分页存储管理和固定分区的区别"><a href="#分页存储管理和固定分区的区别" class="headerlink" title="分页存储管理和固定分区的区别"></a>分页存储管理和固定分区的区别</h5><ol>
<li>每个帧非常小</li>
<li>一个进程可以占用多个帧</li>
<li>每个程序所占用的多个帧不必是连续的</li>
</ol>
<h4 id="分页存储管理的数据结构"><a href="#分页存储管理的数据结构" class="headerlink" title="分页存储管理的数据结构"></a>分页存储管理的数据结构</h4><ol>
<li>位示图（与动态分区管理相同）</li>
<li>页表(Page Table, PT):每个进程一张，记录了本进程的分页和占用帧的情况<br><img src="/2018/06/19/操作系统复习/图片4.jpg" alt="页表"></li>
</ol>
<h4 id="分页存储管理的页面分配算法"><a href="#分页存储管理的页面分配算法" class="headerlink" title="分页存储管理的页面分配算法"></a>分页存储管理的页面分配算法</h4><ol>
<li>计算本进程需要的总帧数N</li>
<li>在位示图中查找,若无足够的空间，不能分配</li>
<li>请求一张PT表</li>
<li>从位示图中找出N的空闲位，并计算它们的帧号，写入PT表</li>
<li>修改位示图</li>
<li>将PT表的起始地址写入进程PCB</li>
<li>分配结束</li>
</ol>
<h4 id="分页存储管理的地址重定位"><a href="#分页存储管理的地址重定位" class="headerlink" title="分页存储管理的地址重定位"></a>分页存储管理的地址重定位</h4><p><code>&lt;页号，页内偏移&gt;</code><br><img src="/2018/06/19/操作系统复习/图片5.jpg" alt=""></p>
<p><img src="/2018/06/19/操作系统复习/图片6.jpg" alt=""></p>
<h4 id="分页管理的页面共享"><a href="#分页管理的页面共享" class="headerlink" title="分页管理的页面共享"></a>分页管理的页面共享</h4><p><code>页面共享</code>，指的是一个页面同时供多个进程使用。带来了一个很重要的问题，即用户访问权限问题。<br><code>页面共享</code>比较不易实现</p>
<h4 id="分页管理的增强管理————快表"><a href="#分页管理的增强管理————快表" class="headerlink" title="分页管理的增强管理————快表"></a>分页管理的增强管理————快表</h4><ol>
<li>快表存储在cache中</li>
<li>快表存放最近使用了的页表项</li>
</ol>
<p><img src="/2018/06/19/操作系统复习/图片7.jpg" alt=""></p>
<h3 id="基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算"><a href="#基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算" class="headerlink" title="基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算"></a>基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算</h3><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>将进程的页表按帧的长度划分为多个页面，并建立高一级的页表来索引它们———<code>二级页表</code><br>如果高一级的页表也必须用多个帧来存放，那么还需要建立更高一级的页表———<code>多级页表</code>  </p>
<p>把整个页表分割成许多小页表，每个称为页表页，它的大小与页框的长度相同，于是每个页表页含有若干个页表表项。页表页从0开始顺序编号，允许被分散存放在不连续的页框中，为了找到页表页，需要建立地址索引，称为页目录表，其表项指出页表页起始地址。系统位每个进程键一张页目录表，它的每个表项指出一个页表项，而页表页的每个表项给出页面和页框的对应关系，<code>页目录表是一级页表</code>，<code>页表页是二级目录</code>，共同构成<code>二级页表机制</code>。</p>
<p><code>例题</code>：若一个由32位二进制组成的地址空间，页面长度为4KB，每个页表项占用4B，请问地址字结构。<br><code>解</code>：</p>
<ol>
<li>因为每个页面长度为4kb，所以，地址的页内偏移为12位。</li>
<li>所以，地址的页号长度位20位。</li>
<li>20位的页号可以表示1M个页面。</li>
<li>因为每个页表项占用4b，所以一个页表的大小是4mb。</li>
<li>又因为每个页面长度为4kb，所以一个页表需要1k个页面来存放</li>
<li>每个页面存放1k个页表项<br>所以，地址字结构是<br>前10位放一级页表在二级页表中的地址，中间10位放每个页面在一级页表中的地址，最后12位放页面偏移量<br><img src="/2018/06/19/操作系统复习/图片8.jpg" alt=""></li>
</ol>
<h4 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h4><p>基于<code>程序局部性原理</code>，对内存和外存空间，实现<code>部分换入</code>和<code>部分对换</code>功能，为用户提供一个比物理内存大得多，可寻址的<code>内存储器</code></p>
<h5 id="请求分页虚存管理"><a href="#请求分页虚存管理" class="headerlink" title="请求分页虚存管理"></a>请求分页虚存管理</h5><p>不把所有的作业信息都放入内存（包括程序和数据），仅放入需要立即使用的的页面，在执行过程中遇到没有装入内存的页面，发生缺页中断，在驱动磁盘装入所需要的页面<br>实现方式：<br>增加页表的内存，增加驻存标志位等信息  </p>
<h6 id="外页表"><a href="#外页表" class="headerlink" title="外页表"></a>外页表</h6><p>为了管理存放在磁盘的页面，操作系统增加了外页表</p>
<ul>
<li>记录了页面和磁盘的物理地址的对应信息，进程启动前由操作系统创建</li>
<li>外页表可以放在磁盘中存储，在发生缺页中断时，外页表才被调入内存。</li>
</ul>
<p><img src="/2018/06/19/操作系统复习/图片9.jpg" alt=""></p>
<h5 id="请求分页虚存管理的优缺点"><a href="#请求分页虚存管理的优缺点" class="headerlink" title="请求分页虚存管理的优缺点"></a>请求分页虚存管理的优缺点</h5><ul>
<li>优点： 有利于多道程序设计，有利于提高内存利用率，减少碎片</li>
<li>缺点： 要有硬件支持（MMU：逻辑地址转换物理地址），要有缺页中断处理机制，增大了系统的开销</li>
</ul>
<h3 id="基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算"><a href="#基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算" class="headerlink" title="基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算"></a>基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算</h3><h4 id="基本存储管理计算有效访存时间"><a href="#基本存储管理计算有效访存时间" class="headerlink" title="基本存储管理计算有效访存时间"></a>基本存储管理计算有效访存时间</h4><p>设t1为访问一次快表的时间，t2为一次内存访问时间：</p>
<p>如果一次查询快表能找到所用的页，我们称作命中。此时的有效访存时间t大约为：<br>                        <code>t = t1 + t2</code><br>如果一次查询快表找不到所用的页，称作没有命中。此时的有效访存时间t将是：<br>                        <code>t = t1 + 2*t2</code><br>一般地，当查询快表的命中率为p，则平均内存有效访问时间T大约为：<br>                        <code>T = p*(t1+t2)+(1-p)*(t1+2*t2)</code></p>
<h4 id="请求分页存储管理的平均访问时间"><a href="#请求分页存储管理的平均访问时间" class="headerlink" title="请求分页存储管理的平均访问时间"></a>请求分页存储管理的平均访问时间</h4><p>设t1位访问一次快表的时间，t2为一次内存访问的时间，t3为缺页处理的时间</p>
<h5 id="不考虑快表命中率和缺页中断时"><a href="#不考虑快表命中率和缺页中断时" class="headerlink" title="不考虑快表命中率和缺页中断时"></a>不考虑快表命中率和缺页中断时</h5><ol>
<li>访问的页面在快表中（一定在内存中）:<br> 查找快表的时间+访问内存的时间<br> <code>t = t1 + t2</code></li>
<li>访问的页面在主存中（不发生缺页中断）:<br> 查找快表的时间+查找页表的时间+访问内存的时间<br> <code>t = t1 + t2 + t2</code></li>
<li>访问的页面不在主存中（发生缺页中断）：<br> 查找快表的时间+查找页表的时间+中断处理的时间（包括修改快表和页表）+查找快表的时间+访问内存的时间<br> <code>t = t1 + t2 + t3 + t1 + t2</code><h5 id="考虑快表命中率和缺页中断时"><a href="#考虑快表命中率和缺页中断时" class="headerlink" title="考虑快表命中率和缺页中断时"></a>考虑快表命中率和缺页中断时</h5>设快表命中为m，缺页中断率为n<br><code>t = m*(t1 + t2) + (1 - m)*[(1 - n)*(t1 + 2*t2) + n*(2*t1 + 2*t2 + t3)]</code></li>
</ol>
<h3 id="缺页从哪儿调入？调入时间分析"><a href="#缺页从哪儿调入？调入时间分析" class="headerlink" title="缺页从哪儿调入？调入时间分析"></a>缺页从哪儿调入？调入时间分析</h3><h3 id="5种页面置换算法的原理和应用"><a href="#5种页面置换算法的原理和应用" class="headerlink" title="5种页面置换算法的原理和应用"></a>5种页面置换算法的原理和应用</h3><ol>
<li>最佳页面替换算法（OPT）<br> 选择置换下次访问距当前时间最长的那些页。但是程序是不可预知的，所以这种算法是不可实现的，但是可用来衡量其他的各种算法</li>
<li>先进先出页面替换算法（FIFO）<br> 置换驻留在内存中时间最长的页<br> 思想：一个很久以前取入内存的页，到现在可能已经不会再用到了。<br> 问题：经常出现一部分程序或数据在整个程序的生命周期中使用频率都很高的情况。</li>
<li>最近最久未用的页面替换算法（LRU）<br> 置换内存中上次使用距当前最远的页。根据程序局部性原理，在较长时间里未被使用的页面，可能不会马上使用到。<br> 为每一页添加一个最后一次访问的时间戳，并且必须在每次访问内存时，都要更新时间戳。<br> 维护一个关于访问页的栈。</li>
<li>时钟Clock算法  <ol>
<li>简单的时钟替换算法<ul>
<li>当页面首次被置入时，其<code>引用位</code>置0</li>
<li>当页面被访问时，<code>引用位</code>置1</li>
<li>当需要进行页面置换时，扫描以查找<code>引用位</code>为0的页框，当遇到<code>引用位</code>为1的页框，就将它的<code>引用位</code>置0，并跳过这个页面，当遇到<code>引用位</code>为0的页框，就把它置换。</li>
<li>如果扫描一圈都没有完成置换，指针会停留在起始位置，此时，就把起始位置的页面置换出去。</li>
</ul>
<ol>
<li>时钟策略改进法<br>（把<code>引用位</code>和<code>修改位</code>结合起来使用）</li>
</ol>
<ul>
<li>最近未被引用，也未被修改(u=0,m=0)</li>
<li>最近被引用，但是未被修改(u=1,m=0)</li>
<li>最近未被引用，但是被修改(u=0,m=1)</li>
<li>最近被引用，且被修改(u=1,m=1)<br>算法执行过程</li>
</ul>
<ol>
<li>第一圈扫描，找出(u=0,m=0)的页面，找到就执行置换</li>
<li>若第1步失败，扫描第2圈，找出(u=0,m=1)的页面，找到就执行置换，在扫描过程中同时把u置0</li>
<li>若第2步失败，此时所有的页面u=0，再执行第1步，必要时执行第2步，则一定可以找出一个可以置换的算法</li>
</ol>
</li>
</ol>
</li>
<li>第二次机会页面替换算法<br>改进FIFO算法，把FIFO算法和<code>引用位结合起来</code></li>
</ol>
<ul>
<li>检查FIFO的队首的<code>引用位</code>,若位0，则这个页面又老又没用，被淘汰。</li>
<li>如果<code>引用位</code>为1，那么说明该页面进入最早，但是还在使用，把引用为置0，并放入队尾<br>思想：对FIFO算法中最老的页面，若它最近仍在使用，把它看作一个新放入的页面，使他还有几会留在内存中。<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4></li>
</ul>
<ol>
<li>用MAT表记录内存使用情况</li>
<li>建立段表ST（一个进程一个）</li>
</ol>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>分段存储管理把进程的逻辑地址空间分成多段，提供二位逻辑地址（段号+段内位移），分段存储管理的实现基于可变分区存储管理原理。分段方式以段位单位来划分和连续存放，为作业的各段分配一个连续的内存空间，而各段之间不一定连续。  </p>
<p>在地址重定位时，根据段号从段表中找出相应段的起始地址，再加上段内偏移就得出了物理地址</p>
<h4 id="分段和分页的比较"><a href="#分段和分页的比较" class="headerlink" title="分段和分页的比较"></a>分段和分页的比较</h4><p>分段是信息的<code>逻辑单位</code>，又源程序的逻辑结构及含义所决定，是用户可见的，段长由用户根据需要来确定，段起始地址可从任何内存地址开始。在分段方式中，源程序（段号、段内位移）经链接装配后仍保持二维（地址）结构，引入的目的是满足用户模块化程序设计的需要。<br>分页是信息的<code>物理单位</code>，与源程序的逻辑结构无关，是用户不可见的，页长由系统（硬件）确定，页面只能从页大小的整数倍地址开始。在分页方式中，源程序（页号，页内位移）经链接装配后变成一维（地址）结构引入的目的是实现离散分配并提高内存利用率</p>
<h3 id="第四章课后计算题和应用题"><a href="#第四章课后计算题和应用题" class="headerlink" title="第四章课后计算题和应用题"></a>第四章课后计算题和应用题</h3><h2 id="PartV设备管理与文件管理"><a href="#PartV设备管理与文件管理" class="headerlink" title="PartV设备管理与文件管理"></a>PartV设备管理与文件管理</h2><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p><strong>设备独立性</strong>是指用户作业和物理设备相互独立，用户编写的程序可访问任何设备而无须事先指定物理设备号，即程序中所指定的设备与物理设备无关，逻辑设备名（号）是用户命名的，是更改的，而物理设备号（名）是系统规定的，是不可更改的。<br>设备独立性带来的好处是：  </p>
<ol>
<li>应用程序与具体物理设备无关，系统增减或变更设备时，不必对源程序进行修改</li>
<li>易于应对I/O设备故障，当一个设备故障时，直接使用另一台设备就可以解决</li>
</ol>
<ul>
<li>用户不指定特定设备，指定逻辑设备，使得用户作业和物理设备独立开来</li>
<li>通过其它途径建立逻辑设备和物理设备之间对应关系，这种特性为“设备独立性”</li>
<li>好处–用户与物理的外围设备无关，系统增减或变更外围设备时程序不必修改；易于对付输入输出设备的故障。</li>
</ul>
<h3 id="缓冲区设置的目的、设置方法、计算"><a href="#缓冲区设置的目的、设置方法、计算" class="headerlink" title="缓冲区设置的目的、设置方法、计算"></a>缓冲区设置的目的、设置方法、计算</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ol>
<li>减少设备的驱动次数</li>
<li>减缓I/O操作对缺页置换的干扰</li>
<li>减缓CPU与I/O设备的速度差距</li>
</ol>
<h4 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h4><ul>
<li>写操作<br>当进程执行写操作输出数据时，先向系统申请一个输出缓冲区，然后将数据送到缓冲区，若是顺序写请求，则不断把数据填到缓冲区，直到装满为止，此后进程可以继续计算，同时，系统将缓冲区内容写到设备上</li>
<li>读操作<br>当进程执行读操作输入数据时，现象系统申请一个缓冲区，系统将设备上的一条物理记录读至缓冲区，根据要求把当前所需要的逻辑记录从缓冲区选出并传送给进程<h4 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h4></li>
<li>无缓冲区<br>  <code>T = n * (T输入+T计算)</code></li>
<li>单缓冲区<br>  <code>T = T输入 + T传输 + (n-1) * MAX(T输入+T传输,T计算) + T计算</code></li>
<li>双缓冲区<br>  <code>T = T输入 + (n-1) * MAX(T输入,T传输+T计算) + T传输 + T计算</code><h3 id="Unix的缓冲池管理机制"><a href="#Unix的缓冲池管理机制" class="headerlink" title="Unix的缓冲池管理机制"></a>Unix的缓冲池管理机制</h3>缓冲池是系统提供的一种共享结构，不归某个进程所有。任何程序都可以申请缓冲池中的一个存储块，用来存储自己的缓冲数据。</li>
<li><strong>空闲缓冲队列(emq)</strong>:该队列上挂有所有可用的空闲缓冲区</li>
<li><strong>输入队列(inq)</strong>:该列队上挂装满输入数据的缓冲区</li>
<li><strong>输出队列(outq)</strong>:该队列上挂装满输出数据的缓冲区</li>
</ul>
<p><img src="/2018/06/19/操作系统复习/图片10.jpg" alt=""></p>
<h3 id="进行一次磁盘读写所需要的时间的计算"><a href="#进行一次磁盘读写所需要的时间的计算" class="headerlink" title="进行一次磁盘读写所需要的时间的计算"></a>进行一次磁盘读写所需要的时间的计算</h3><h4 id="磁盘性能参数"><a href="#磁盘性能参数" class="headerlink" title="磁盘性能参数"></a>磁盘性能参数</h4><ul>
<li>寻道时间（t1）：将磁头臂移到目标磁道所用的时间</li>
<li>旋转延迟时间（t2）：将磁盘带访问的扇区移动到读/写磁头可访问的位置所需要的时间</li>
<li>传输时间（t3）：读/写操作数据传输所需要的时间</li>
</ul>
<p>一次磁盘读取操作是三个操作时间的总和：<br><code>T = t1 + t2 + t3</code></p>
<ol>
<li>寻道时间 t1 = s（磁盘启动时间） + m（平均跨越一道的时间） * n（跨越的道数）</li>
<li>平均旋转延迟时间 t2 = r（旋转速度(转/秒)）/2</li>
<li>传输时间 t3 = b（要传送的字节数）/N（一个磁道中的字节数） * r（旋转速度）</li>
</ol>
<h3 id="4种磁盘调度算法原理及计算"><a href="#4种磁盘调度算法原理及计算" class="headerlink" title="4种磁盘调度算法原理及计算"></a>4种磁盘调度算法原理及计算</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>按请求到来的顺序进行服务<br>优点： 比较公平<br>缺点： 通常不能提供最快的服务</p>
<h4 id="最短寻道时间优先算法-SSTF"><a href="#最短寻道时间优先算法-SSTF" class="headerlink" title="最短寻道时间优先算法 SSTF"></a>最短寻道时间优先算法 SSTF</h4><p>从当前磁头的位置选择最短寻道时间的请求，即选择和当前磁头位置最近的请求<br>优点： 大大提高了性能<br>缺点： 没考虑磁头转向的时间；有可能出现“粘着”，“饥饿”等现象，即磁头只响应中间位置的请求，对两头位置较远的请求不予理睬</p>
<h4 id="电梯调度-SCAN"><a href="#电梯调度-SCAN" class="headerlink" title="电梯调度 SCAN"></a>电梯调度 SCAN</h4><p>磁盘臂从磁盘的一端向另一端移动，当磁头经过每个柱面时，处理位于该柱面的请求，当前面已经没有请求了，磁头转向，继续处理<br>优点： 性能比较良好，且不会出现“饥饿”，“粘着”的现象<br>缺点： 需要知道磁头的当前位置和磁头的移动方向；某些请求处理可能不及时（恰好磁头进过它，要等磁头绕一圈回来处理完所有请求）<br><img src="/2018/06/19/操作系统复习/图片11.jpg" alt=""></p>
<h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><p>SCAN的变种，磁头从一端移动到另一端，随着移动不断处理请求。不过，当磁头移动到另一端时，马上返回，中间不处理请求。</p>
<h3 id="用户程序发出磁盘I-O请求后，系统一般的处理流程"><a href="#用户程序发出磁盘I-O请求后，系统一般的处理流程" class="headerlink" title="用户程序发出磁盘I/O请求后，系统一般的处理流程"></a>用户程序发出磁盘I/O请求后，系统一般的处理流程</h3><p><strong>用户程序→系统调用处理程序→设备驱动程序→中断处理程序</strong></p>
<h3 id="文件的4种物理存储结构"><a href="#文件的4种物理存储结构" class="headerlink" title="文件的4种物理存储结构"></a>文件的4种物理存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>将文件中逻辑上连续的信息存放到存储介质的相邻物理块上形成的顺序结构，叫做顺序文件</p>
<ul>
<li>优点：  <ol>
<li>管理简单</li>
<li>存取速度块</li>
<li>既合适顺序存储，也合适随机存取</li>
</ol>
</li>
<li>缺点：  <ol>
<li>外存空间利用率低</li>
<li>必须预先知道文件长度</li>
<li>不便于文件的扩展<h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4>连接结构的特点是使用连接字，又称指针，来表示文件中各条记录之间的关系<h5 id="显式链接存储结构"><a href="#显式链接存储结构" class="headerlink" title="显式链接存储结构"></a>显式链接存储结构</h5>将用于链接文件各盘块的指针，“显示”的存放在外存的一张链接表中。该表在整个磁盘仅设置了一张，登记了分配给文件所有盘块的链接关系，故将该表称为<code>文件分配表FAT</code><br><img src="/2018/06/19/操作系统复习/图片12.jpg" alt=""><h5 id="隐式链接存储结构"><a href="#隐式链接存储结构" class="headerlink" title="隐式链接存储结构"></a>隐式链接存储结构</h5>每个文件的FCB中只登记起始盘块和末盘块号，其他盘块号均由链接指针记录。<br><img src="/2018/06/19/操作系统复习/图片13.jpg" alt=""></li>
</ol>
</li>
</ul>
<h5 id="链式存储的特点"><a href="#链式存储的特点" class="headerlink" title="链式存储的特点"></a>链式存储的特点</h5><ul>
<li>采用离散分配方式：磁盘上的所有空闲块都可以被利用，消除了外部碎片</li>
<li>易于文件增长或收缩：当文件需要增长时，可动态分配新盘块，并用指针链接起来，收缩时只要从链中取消不需要的块即可</li>
<li>指针本身需要存储空间：如果采用隐式存储，磁盘块中需要存储空间。如果采用显示存储，需要为FAT表分配空间</li>
<li>链接指针的可靠性是个问题：存取文件时，如果哪个指针丢失或错误，指针可能指向其他文件造成不可预估的错误</li>
</ul>
<h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><p>为每个文件分配一个索引块，索引块登记了个逻辑块与外存物理块的对应关系，并在文件FCB中登记该文件索引块的地址<br><img src="/2018/06/19/操作系统复习/图片14.jpg" alt=""></p>
<ul>
<li>既适合顺序存取，也合适随机存取</li>
<li>索引结构易实现记录的增、删和插入</li>
<li>缺点是由于索引表的建立增加了存储空间的开销</li>
</ul>
<h5 id="二级索引结构"><a href="#二级索引结构" class="headerlink" title="二级索引结构"></a>二级索引结构</h5><p>将索引表离散存储，即将索引表本身分为若干个逻辑块，存储在若干个物理盘块中，将索引表所占的各盘块号记入另一个索引表————索引表的索引表。这种结构就成为二级索引结构</p>
<p><img src="/2018/06/19/操作系统复习/图片15.jpg" alt=""></p>
<h4 id="UNIX混合存储结构"><a href="#UNIX混合存储结构" class="headerlink" title="UNIX混合存储结构"></a>UNIX混合存储结构</h4><p><img src="/2018/06/19/操作系统复习/图片16.jpg" alt=""><br>说明：UNIX操作系统采用了多级混合索引结构（包括直接寻址、一级索引、二级索引和三级索引），规定每个索引结点使用13个地址登记项，其中，前10个登记项直接指出存放文件信息的盘块号，属于直接寻址，第11个登记项指向一级索引块，内涵若干个一级索引存储块。第12个登记项指向二级索引块，第13个登记项指向三级索引块。</p>
<h3 id="文件目录、文件的索引节点"><a href="#文件目录、文件的索引节点" class="headerlink" title="文件目录、文件的索引节点"></a>文件目录、文件的索引节点</h3><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p>文件目录是一种数据结构，由若干目录项构成，每个目录项对应其中一个文件的FCB(包括文件名、文件体的物理地址、存取控制信息等)，文件体另外存放。文件目录用于检索文件，一般的文件目录包括以下内容：  </p>
<ol>
<li>文件存储控制信息，如用户名、文件名、文件类型、文件访问权限（可读可写、只读、只执行等）</li>
<li>文件结构信息，如文件的逻辑结构，文件的物理结构，文件在存储介质上的位置，文件长度等</li>
<li>文件管理信息，如文件的建立日期，文件被修改的信息，文件的保留日期和记账信息等</li>
</ol>
<h4 id="建立文件目录的主要目的"><a href="#建立文件目录的主要目的" class="headerlink" title="建立文件目录的主要目的"></a>建立文件目录的主要目的</h4><ol>
<li>实现“按名存取”。用户只需向系统提供所需访问文件的名字，便能快速准确地找到指定文件在外存上的位置。</li>
<li>提高对目录的检索速度。合理组织目录结构，缩短目录检索所需时间，从而提高文件的存取速度。</li>
<li>允许文件共享。多用户系统中，允许多个用户共享同一个物理文件，以节约外存空间。</li>
<li>允许文件重名。用户可按照自己的习惯给自己的文件命名，不必担心是否会跟别的用户文件重名。<h4 id="文件索引结点"><a href="#文件索引结点" class="headerlink" title="文件索引结点"></a>文件索引结点</h4>由于文件的FCB信息较大，需要的存储空间较大，所以查找一次文件需要的时间比较多，为了解决这种情况，就引入了文件索引结点</li>
</ol>
<p>索引结点是将文件名和文件信息分开记录，将文件的描述信息单独形成一个称为索引结点的数据结构</p>
<p>在unix中，索引结点称为i结点，一个目录项仅占16个字节，其中14个字节为文件名，2个字节为结点号。</p>
<h3 id="Unix、Linux空闲盘块成组链接组织方式"><a href="#Unix、Linux空闲盘块成组链接组织方式" class="headerlink" title="Unix、Linux空闲盘块成组链接组织方式"></a>Unix、Linux空闲盘块成组链接组织方式</h3><h3 id="第五、六章课后计算题和应用题"><a href="#第五、六章课后计算题和应用题" class="headerlink" title="第五、六章课后计算题和应用题"></a>第五、六章课后计算题和应用题</h3><p>总：回顾整个操作系统各个功能模块的功能及功能实现有关的数据结构和算法</p>
<pre><code>按照复习提纲，结合课本、课件、课堂例题、课后作业题进行复习，特别是各章节授课过程中讲过的例题和各章习题，必须掌握其解题思路和方法。
</code></pre>
      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="LiLinfeng 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="LiLinfeng 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <div>
  		
   			<div>
    
        <div style="text-align:center;color: #ccc;font-size:8px;">-------------本文到此结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  		
	</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/复习/" rel="tag"><i class="fa fa-tag"></i> 复习</a>
          
            <a href="/tags/操作系统/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/12/『小白日记』join函数学习笔记/" rel="next" title="『小白日记』join函数学习笔记">
                <i class="fa fa-chevron-left"></i> 『小白日记』join函数学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
 	<div id="gitalk-container"></div>





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="LiLinfeng" />
            
              <p class="site-author-name" itemprop="name">LiLinfeng</p>
              <p class="site-description motion-element" itemprop="description">Be a dreamer,but not just a dreamer!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/734432041" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:734432041@qq.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#2018年春季学期计算机操作系统原理复习提纲"><span class="nav-number">1.</span> <span class="nav-text">2018年春季学期计算机操作系统原理复习提纲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-I操作系统概述"><span class="nav-number">1.1.</span> <span class="nav-text">Part I操作系统概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的资源管理技术"><span class="nav-number">1.1.1.</span> <span class="nav-text">操作系统的资源管理技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复用"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">虚拟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">抽象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">1.1.2.</span> <span class="nav-text">操作系统的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的主要特性"><span class="nav-number">1.1.3.</span> <span class="nav-text">操作系统的主要特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的发展与分类"><span class="nav-number">1.1.4.</span> <span class="nav-text">操作系统的发展与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理操作系统"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">批处理操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时操作系统"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">分时操作系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时操作系统"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">实时操作系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统提供给用户的几种接口"><span class="nav-number">1.1.5.</span> <span class="nav-text">操作系统提供给用户的几种接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是系统调用-API、库函数和系统调用之间的区别和联系"><span class="nav-number">1.1.6.</span> <span class="nav-text">什么是系统调用? API、库函数和系统调用之间的区别和联系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用与函数调用之间的区别"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">系统调用与函数调用之间的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是原语？用户应用程序如何调用原语功能？举例Linux原语"><span class="nav-number">1.1.7.</span> <span class="nav-text">什么是原语？用户应用程序如何调用原语功能？举例Linux原语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原语"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">原语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#举例Linux原语"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">举例Linux原语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章课后计算题"><span class="nav-number">1.1.8.</span> <span class="nav-text">第一章课后计算题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-II处理器管理"><span class="nav-number">1.2.</span> <span class="nav-text">Part II处理器管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU的两种工作状态"><span class="nav-number">1.2.1.</span> <span class="nav-text">CPU的两种工作状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内核态（系统态、管理态、管态）"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">内核态（系统态、管理态、管态）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态（目态）"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">用户态（目态）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断和异常"><span class="nav-number">1.2.2.</span> <span class="nav-text">中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#中断的分类"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">中断的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#外中断"><span class="nav-number">1.2.2.1.1.1.</span> <span class="nav-text">外中断</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#内中断"><span class="nav-number">1.2.2.1.1.2.</span> <span class="nav-text">内中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断响应需要执行的四件事"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">中断响应需要执行的四件事</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与程序、进程与线程之间的区别联系"><span class="nav-number">1.2.3.</span> <span class="nav-text">进程与程序、进程与线程之间的区别联系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的目的"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">进程的目的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的属性"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">进程的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程和程序的区别和联系"><span class="nav-number">1.2.3.1.3.</span> <span class="nav-text">进程和程序的区别和联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程"><span class="nav-number">1.2.3.1.4.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程和线程的区别和联系"><span class="nav-number">1.2.3.1.5.</span> <span class="nav-text">进程和线程的区别和联系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父进程与子进程之间的关系"><span class="nav-number">1.2.4.</span> <span class="nav-text">父进程与子进程之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的3态模型、进程的5态模型、引发各种状态转换的原因"><span class="nav-number">1.2.5.</span> <span class="nav-text">进程的3态模型、进程的5态模型、引发各种状态转换的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的三级调度"><span class="nav-number">1.2.6.</span> <span class="nav-text">操作系统的三级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#高级调度"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">高级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中级调度"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">中级调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#低级调度"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">低级调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用的作业调度算法、进程调度算法"><span class="nav-number">1.2.7.</span> <span class="nav-text">常用的作业调度算法、进程调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章课后作业调度、进程调度有关的计算题"><span class="nav-number">1.2.8.</span> <span class="nav-text">第二章课后作业调度、进程调度有关的计算题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PartIII同步、通信与死锁"><span class="nav-number">1.3.</span> <span class="nav-text">PartIII同步、通信与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程并发的概念；互斥、同步的概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程并发的概念；互斥、同步的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发执行进程的目的"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">并发执行进程的目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程互斥的概念"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">进程互斥的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程同步的概念"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">进程同步的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步和互斥的关系"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">同步和互斥的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥管理准则"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">互斥管理准则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）"><span class="nav-number">1.3.2.</span> <span class="nav-text">分析利用软件方法解决互斥问题的漏洞（分析Dekker的几次尝试）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一次尝试"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">第一次尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二次尝试"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">第二次尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第三次尝试"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">第三次尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第四次尝试"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">第四次尝试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#“正确”的算法"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">“正确”的算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用信号量机制（PV操作）解决进程同步互斥问题"><span class="nav-number">1.3.3.</span> <span class="nav-text">应用信号量机制（PV操作）解决进程同步互斥问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量机制原理"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">信号量机制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#p原语的功能"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">p原语的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#V原语的功能"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">V原语的功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父子进程之间进行通信的几种方式（结合实验课程）"><span class="nav-number">1.3.4.</span> <span class="nav-text">父子进程之间进行通信的几种方式（结合实验课程）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号通信"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">信号通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#软中断的概念"><span class="nav-number">1.3.4.1.1.</span> <span class="nav-text">软中断的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软中断的用法"><span class="nav-number">1.3.4.1.2.</span> <span class="nav-text">软中断的用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#中断机制和信号机制的比较"><span class="nav-number">1.3.4.1.3.</span> <span class="nav-text">中断机制和信号机制的比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管道通讯"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">管道通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享内存通讯"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">共享内存通讯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列通讯"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">消息队列通讯</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的基本概念、死锁产生的原因、4个必要条件"><span class="nav-number">1.3.5.</span> <span class="nav-text">死锁的基本概念、死锁产生的原因、4个必要条件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的基本概念"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">死锁的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁产生的原因"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">死锁产生的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁产生的四个必要条件"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">死锁产生的四个必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁预防、死锁避免、死锁检测的概念"><span class="nav-number">1.3.6.</span> <span class="nav-text">死锁预防、死锁避免、死锁检测的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁预防"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁避免"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#银行家算法的数据结构"><span class="nav-number">1.3.6.2.1.</span> <span class="nav-text">银行家算法的数据结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁检测"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">死锁检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#资源分配图"><span class="nav-number">1.3.6.3.1.</span> <span class="nav-text">资源分配图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁定理"><span class="nav-number">1.3.6.3.2.</span> <span class="nav-text">死锁定理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章课后应用题和计算题"><span class="nav-number">1.3.7.</span> <span class="nav-text">第三章课后应用题和计算题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PartIV存储管理"><span class="nav-number">1.4.</span> <span class="nav-text">PartIV存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态地址重定位和动态地址重定位"><span class="nav-number">1.4.1.</span> <span class="nav-text">静态地址重定位和动态地址重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态地址重定位"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">静态地址重定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态地址重定位"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">动态地址重定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）"><span class="nav-number">1.4.2.</span> <span class="nav-text">动态多分区存储管理的管理机制（数据结构、主存分配算法、回收算法、地址重定位）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#固定分区"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">固定分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变分区"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">可变分区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内碎片"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">内碎片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#外碎片"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">外碎片</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主存分配算法"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">主存分配算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收算法"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#地址重定位"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">地址重定位</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存不足的存储管理技术"><span class="nav-number">1.4.3.</span> <span class="nav-text">内存不足的存储管理技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移动技术-程序浮动"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">移动技术(程序浮动)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#程序浮动的要求"><span class="nav-number">1.4.3.1.1.</span> <span class="nav-text">程序浮动的要求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对换技术（主存扩充）"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">对换技术（主存扩充）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#交换技术"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">交换技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#磁盘文件区和交换区的不同"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">磁盘文件区和交换区的不同</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖技术（主存扩充）"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">覆盖技术（主存扩充）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页式存储管理的管理机制（基本分页、请求分页）"><span class="nav-number">1.4.4.</span> <span class="nav-text">分页式存储管理的管理机制（基本分页、请求分页）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分页存储管理的基本原理"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">分页存储管理的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分页存储管理和固定分区的区别"><span class="nav-number">1.4.4.1.1.</span> <span class="nav-text">分页存储管理和固定分区的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页存储管理的数据结构"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">分页存储管理的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页存储管理的页面分配算法"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">分页存储管理的页面分配算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页存储管理的地址重定位"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">分页存储管理的地址重定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页管理的页面共享"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">分页管理的页面共享</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页管理的增强管理————快表"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">分页管理的增强管理————快表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算"><span class="nav-number">1.4.5.</span> <span class="nav-text">基本分页式（包括两级页表机制、多级页表机制）地址字结构的有关计算、请求分页式存储管理的虚实地址之间的重定位及地址计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多级页表"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟存储管理"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">虚拟存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#请求分页虚存管理"><span class="nav-number">1.4.5.2.1.</span> <span class="nav-text">请求分页虚存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#外页表"><span class="nav-number">1.4.5.2.1.1.</span> <span class="nav-text">外页表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求分页虚存管理的优缺点"><span class="nav-number">1.4.5.2.2.</span> <span class="nav-text">请求分页虚存管理的优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算"><span class="nav-number">1.4.6.</span> <span class="nav-text">基本分页存储管理的平均访存时间计算（使用快表）、请求分页存储管理的平均访存时间计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本存储管理计算有效访存时间"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">基本存储管理计算有效访存时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求分页存储管理的平均访问时间"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">请求分页存储管理的平均访问时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不考虑快表命中率和缺页中断时"><span class="nav-number">1.4.6.2.1.</span> <span class="nav-text">不考虑快表命中率和缺页中断时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#考虑快表命中率和缺页中断时"><span class="nav-number">1.4.6.2.2.</span> <span class="nav-text">考虑快表命中率和缺页中断时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺页从哪儿调入？调入时间分析"><span class="nav-number">1.4.7.</span> <span class="nav-text">缺页从哪儿调入？调入时间分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5种页面置换算法的原理和应用"><span class="nav-number">1.4.8.</span> <span class="nav-text">5种页面置换算法的原理和应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段存储管理"><span class="nav-number">1.4.9.</span> <span class="nav-text">分段存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-1"><span class="nav-number">1.4.9.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本原理"><span class="nav-number">1.4.9.2.</span> <span class="nav-text">基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分段和分页的比较"><span class="nav-number">1.4.9.3.</span> <span class="nav-text">分段和分页的比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章课后计算题和应用题"><span class="nav-number">1.4.10.</span> <span class="nav-text">第四章课后计算题和应用题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PartV设备管理与文件管理"><span class="nav-number">1.5.</span> <span class="nav-text">PartV设备管理与文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设备独立性"><span class="nav-number">1.5.1.</span> <span class="nav-text">设备独立性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区设置的目的、设置方法、计算"><span class="nav-number">1.5.2.</span> <span class="nav-text">缓冲区设置的目的、设置方法、计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目的"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置方式"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">设置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间计算"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">时间计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix的缓冲池管理机制"><span class="nav-number">1.5.3.</span> <span class="nav-text">Unix的缓冲池管理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进行一次磁盘读写所需要的时间的计算"><span class="nav-number">1.5.4.</span> <span class="nav-text">进行一次磁盘读写所需要的时间的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘性能参数"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">磁盘性能参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4种磁盘调度算法原理及计算"><span class="nav-number">1.5.5.</span> <span class="nav-text">4种磁盘调度算法原理及计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先来先服务FCFS"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">先来先服务FCFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短寻道时间优先算法-SSTF"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">最短寻道时间优先算法 SSTF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#电梯调度-SCAN"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">电梯调度 SCAN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-SCAN"><span class="nav-number">1.5.5.4.</span> <span class="nav-text">C-SCAN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户程序发出磁盘I-O请求后，系统一般的处理流程"><span class="nav-number">1.5.6.</span> <span class="nav-text">用户程序发出磁盘I/O请求后，系统一般的处理流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件的4种物理存储结构"><span class="nav-number">1.5.7.</span> <span class="nav-text">文件的4种物理存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序存储结构"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接文件"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">链接文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#显式链接存储结构"><span class="nav-number">1.5.7.2.1.</span> <span class="nav-text">显式链接存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#隐式链接存储结构"><span class="nav-number">1.5.7.2.2.</span> <span class="nav-text">隐式链接存储结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链式存储的特点"><span class="nav-number">1.5.7.2.3.</span> <span class="nav-text">链式存储的特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引存储结构"><span class="nav-number">1.5.7.3.</span> <span class="nav-text">索引存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二级索引结构"><span class="nav-number">1.5.7.3.1.</span> <span class="nav-text">二级索引结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UNIX混合存储结构"><span class="nav-number">1.5.7.4.</span> <span class="nav-text">UNIX混合存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件目录、文件的索引节点"><span class="nav-number">1.5.8.</span> <span class="nav-text">文件目录、文件的索引节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件目录"><span class="nav-number">1.5.8.1.</span> <span class="nav-text">文件目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立文件目录的主要目的"><span class="nav-number">1.5.8.2.</span> <span class="nav-text">建立文件目录的主要目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件索引结点"><span class="nav-number">1.5.8.3.</span> <span class="nav-text">文件索引结点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unix、Linux空闲盘块成组链接组织方式"><span class="nav-number">1.5.9.</span> <span class="nav-text">Unix、Linux空闲盘块成组链接组织方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五、六章课后计算题和应用题"><span class="nav-number">1.5.10.</span> <span class="nav-text">第五、六章课后计算题和应用题</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="piggy-bank"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiLinfeng</span>

  

  
</div>




  <!-- <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.3.0</div>
-->




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '556020ae595df9eadeeb',
          clientSecret: '3a68e1cf6857aa7ab6d96c15d3af4d35a8c220f7',
          repo: '734432041.github.io',
          owner: '734432041',
          admin: ['734432041'],
          id: '<%= page.title %>',
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>


  





  

  

  

  

  
  

  

  

  

  

  


  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

</body>
</html>
